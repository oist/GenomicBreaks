---
title: "GenomeRearrangementAlgorithm"
author: "Bruna Fistarol"
date: "2024-02-06"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Genome Rearrangement Algorithm - Sorting by Reversals

This vignette explains how the algorithm for rearranging by inversions was written, based on Hannenhalli and Pevzner work "Transforming Cabbage into Turnip: Polynomial Algorithm for Sorting Signed Permutations by Reversals", from 1999.

All required functions to sort by reversals are implemented on the following R script:

```{r}
source("InversionsAlgorithm.R")
```

## Genome representation

The algorithm works in order to rearrange a numeric sequence by inversions in order to obtain the sorted sequence $1, 2, ..., n$, where $n$ is the number of DNA fragments from a one-to-one relationship of two genomes.

Therefore, to transform a genome into another, we have to define one genome as a sorted sequence $1, 2, ..., n$ (the identity permutation), and the second one as a signed permutation $\pi$ from the first one - Genome Breaks package is able to do this job. A negative number in the sequence means an inverted DNA fragment.

### Transforming a signed sequence into an unsigned sequence

A largely used structure in the case of a signed permutation (which means we have inversions) is representing a fragment as a pair of numbers removing the signal, where we replace each positive element $i$ of $\pi$ by $(2i, 2i+1)$ and each negative element $-i$ of $\pi$ by $(2i+1, 2i)$. We also add two elements $\pi(0)=1$ and $\pi(n+1) = 2n+2$ - these numbers will be useful to identify breakpoints at the beginning and end of the strand. The reason to use this structure is the fact that it is way much better to apply graph approaches. Lets use an example given by the paper:

```{r Defining the genome structure}

query_sequence <- c(3, -5, 8, -6, 4, -7, 9, 2, 1, 10, -11)

#transforming a signed permutation into an unsigned permutation to construct the breakpoint graph

query_sequence_unsig <- sig2unsig(query_sequence)

query_sequence_unsig
```

### Implementing the inversion operation

Some carry is required when applying operations in this type of representation above. A fragment n will be represented by $2n$ and $2n+1$, hence, numbers in these forms cannot be separated, i.e., an operation needs to start in an even index and finish in an odd index, once we added two extremities in the vector, so any DNA fragment starts in an even index and finishes in an odd index.

```{r}

#perform an inversion of the third fragment
inversion(query_sequence_unsig, 2, 17)

```

If we perform some inversion operations, we can sort the genome:

```{r}
inversion(query_sequence_unsig, 2, 17) |> inversion(4, 19) |> inversion(10, 15) |> inversion(14, 17) |> inversion(22, 23) |> inversion(2, 5) |> inversion(8, 11)
```

Our problem is finding these sequence of rearrangements with a minimal number of movements, called *reversal distance*.

In order to get a sequence of inversions, it is sufficient to type

```{r}
inversions_rearrangement(query_sequence_unsig)
```

or

```{r}
inversions_rearrangement(query_sequence, unsigned=FALSE)
```

Each line represents the positions of the inversion in the unsigned sequence.

If you want to check the steps of the algorithm, read the topics below.

## Creating a breakpoint graph

```{r Creating and visualizing a breakpoint graph}

g <- breakpoint_graph(query_sequence_unsig)

layout_matrix <- matrix(ncol = 2, nrow = vcount(g))
layout_matrix[, 2] <- 0
layout_matrix[, 1] <- query_sequence_unsig

#plot(g, layout = layout_matrix, rescale = FALSE, xlab = "", ylab = "", main = "Custom Node Order")

plot(g, edge.color = E(g)$color, edge.width = 4, vertex.size = 20, vertex.color="lightgreen")
```

Each number in a node represents an extremity of a fragment (remember that we have created a unsigned permutation, where each fragment $i$ was replaced by $2i, 2i+1$ and we add the extremities $1$ and $2n+2$, where $n$ is the number of fragments).

A black edge is created when two fragments are adjacent but not consecutive, i.e., we have

$$ |i-j|\neq 1, ~~~~~~ |\pi_i - \pi_j|=1  $$.

Hence, they indicate the presence of a breakpoint. In the unsigned permutation, we create a black edge between $2i+1$ and $2j$ if these conditions are satisfied.

A gray edge is created when two fragments are consecutive but not adjacent,

$$ |i-j|= 1, ~~~~~~ |\pi_i - \pi_j|\neq 1  $$.

Gray edges indicates "what we should have", or which fragment comes next. In the unsigned permutation, we create a gray edge between $2i+1$ and $2j$ if these conditions are satisfied.

### Cycles

define cycles

### Counting breakpoints and cycles in the breakpoint graph

```{r Count breakpoints and cycles}

#count the number of breakpoints (including artificial extremities)
bp_count(query_sequence_unsig)

#count the number of cycles excluding single nodes
cycle_count(g)
```

### Orientation of edges and cycles

define orientation (edge and cycle)

### Extension of gray edges

We need to find a characteristic called "interleaving" between gray nodes, which essentially says if two gray nodes overlap, but none of them contains the another one. With this, we can establish interactions in the graph of connected components.

## Components graph

```{r}
h <- components_graph(g, query_sequence_unsig)

plot(h)
```

## Hurdles

```{r Counting hurdles and superhurdles}

info <- hurdles_count(g, query_sequence_unsig)
```

## Superhurdles

```{r}

superhurdles_count(info, g, query_sequence_unsig)

```

## Fortress

```{r Is it fortress?}
#analyze if the permutation is a fortress
is_fortress(superhurdles)

  
  #a permutation is a fortress if the number of hurdles is odd and all hurdles are superhurdles
  #return 1 if it is fortress
  #return 0 otherwise
  

```

# Performing the rearrangement

```{r Generating unsigned target sequence and simulated scrambling}
dna_blocks <- 8
number_inversions <- 5


#simulating a number of random inversions given by "simulations" in an unsigned sequence s
simulate_inversion(s, simulations)

target_sequence <- 1:dna_blocks 
target_sequence_unsig <- sig2unsig(target_sequence)

simulate_inversion_res <- simulate_inversion(target_sequence_unsig, number_inversions)

positions <- simulate_inversion_res$positions
query_sequence_unsig <- simulate_inversion_res$sequence 
```

```{r Another cases from the paper}
#query_sequence <- c(5, 7, 6, 8, 1, 3, 2, 4)

#query_sequence <- c(2, 4, 3, 5, 7, 6, 8, 1)

#query_sequence <- c(1, -5, 4, -3, 2)

#query_sequence_unsig <- sig2unsig(query_sequence)

#query_sequence_unsig <- c(0,45,46,43,44,1,2,7,8,13,14,11,12,9,10,15,16,5,6,3,4,17,18,23,24,29,30,27,28,25,26,31,32,37,38,35,36,33,34,39,40,21,22,19,20,41,42,47) +1

query_sequence_unsig <- c(0,45,46,43,44,1,2,7,8,13,14,11,12,9,10,32,31,26,25,28,27,30,29,24,23,18,17,4,3,6,5,16,15,37,38,35,36,33,34,39,40,21,22,19,20,41,42,47)+1

```

```{r Performing the rearrangements}

inversions_rearrangement(seq, unsigned=TRUE)
  
```
