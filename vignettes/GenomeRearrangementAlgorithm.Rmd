---
title: "GenomeRearrangementAlgorithm"
author: "Bruna Fistarol"
date: "2024-02-06"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Genome Rearrangement Algorithm - Sorting by Reversals

This vignette explains how the algorithm for rearranging by inversions was written, based on Hannenhalli and Pevzner work "Transforming Cabbage into Turnip: Polynomial Algorithm for Sorting Signed Permutations by Reversals", from 1999.

All required functions to sort by reversals are implemented on the following R script:

```{r}
source("InversionsAlgorithm.R")
```

## Genome representation

The algorithm works in order to rearrange a numeric sequence by inversions in order to obtain the sorted sequence $1, 2, ..., n$, where $n$ is the number of DNA fragments from a one-to-one relationship of two genomes.

Therefore, to transform a genome into another, we have to define one genome as a sorted sequence $1, 2, ..., n$ (the identity permutation), and the second one as a signed permutation $\pi$ from the first one - Genome Breaks package is able to do this job. A negative number in the sequence means an inverted DNA fragment.

### Transforming a signed sequence into an unsigned sequence

A largely used structure in the case of a signed permutation (which means we have inversions) is representing a fragment as a pair of numbers removing the signal, where we replace each positive element $i$ of $\pi$ by $(2i, 2i+1)$ and each negative element $-i$ of $\pi$ by $(2i+1, 2i)$. We also add two elements $\pi(0)=1$ and $\pi(n+1) = 2n+2$ - these numbers will be useful to identify breakpoints at the beginning and end of the strand. The reason to use this structure is the fact that it is way much better to apply graph approaches. Lets use an example given by the paper:

```{r Defining the genome structure}

query_sequence <- c(3, -5, 8, -6, 4, -7, 9, 2, 1, 10, -11)

#transforming a signed permutation into an unsigned permutation to construct the breakpoint graph

query_sequence_unsig <- sig2unsig(query_sequence)

query_sequence_unsig
```

### Implementing the inversion operation

Some carry is required when applying operations in this type of representation above. A fragment n will be represented by $2n$ and $2n+1$, hence, numbers in these forms cannot be separated, i.e., an operation needs to start in an even index and finish in an odd index, once we added two extremities in the vector, so any DNA fragment starts in an even index and finishes in an odd index.

The terms "inversions" and "reversals" are synonymous and are used here interchangeably. 

```{r}

#perform an inversion of the third fragment
inversion(query_sequence_unsig, 2, 17)

```

If we perform some inversion operations, we can sort the genome:

```{r}
inversion(query_sequence_unsig, 2, 17) |> inversion(4, 19) |> inversion(10, 15) |> inversion(14, 17) |> inversion(22, 23) |> inversion(2, 5) |> inversion(8, 11)
```

Our problem is finding these sequence of rearrangements with a minimal number of movements, called *reversal distance*, noted by $d(\pi)$.

In order to get a sequence of inversions, it is sufficient to type

```{r}
inversions_rearrangement(query_sequence_unsig)
```

or

```{r}
inversions_rearrangement(query_sequence, unsigned=FALSE)
```

Each line represents the positions of the inversion in the unsigned sequence.

If you want to check the steps of the algorithm, read the topics below.

## Creating a breakpoint graph

```{r Creating and visualizing a breakpoint graph}

g <- breakpoint_graph(query_sequence_unsig)

layout_matrix <- matrix(ncol = 2, nrow = vcount(g))
layout_matrix[, 2] <- 0
layout_matrix[, 1] <- query_sequence_unsig

#plot(g, layout = layout_matrix, rescale = FALSE, xlab = "", ylab = "", main = "Custom Node Order")

plot(g, edge.color = E(g)$color, edge.width = 4, vertex.size = 20, vertex.color="lightgreen")
```

Each number in a node represents an extremity of a fragment (remember that we have created a unsigned permutation, where each fragment $i$ was replaced by $2i, 2i+1$ and we add the extremities $1$ and $2n+2$, where $n$ is the number of fragments).

A black edge is created when two fragments are adjacent but not consecutive, i.e., we have

$$ |i-j|\neq 1, ~~~~~~ |\pi_i - \pi_j|=1  $$.

Hence, they indicate the presence of a breakpoint. In the unsigned permutation, we create a black edge between $2i+1$ and $2j$ if these conditions are satisfied.

A gray edge is created when two fragments are consecutive but not adjacent,

$$ |i-j|= 1, ~~~~~~ |\pi_i - \pi_j|\neq 1  $$.

Gray edges indicates "what we should have", or which fragment should come next. In the unsigned permutation, we create a gray edge between $2i+1$ and $2j$ if these conditions are satisfied.

### Counting breakpoints and cycles in the breakpoint graph

We can define by cycles all connected components with more than one node on the breakpoint graph. Lets write $b(\pi)$ for the number of breakpoints and $c(\pi)$ for the number of cycles in the breakpoint graph.

```{r Count breakpoints and cycles}

#count the number of breakpoints (including artificial extremities)
bp_count(query_sequence_unsig)

#count the number of cycles excluding single nodes
cycle_count(g)
```

In our example, $b(\pi)=12$ and $c(\pi)=6$.

In 1996, Bafna and Pevzner showed that every inversion can change the parameter $b(\pi) - c(\pi)$ by at most 1. Therefore, we can have a lower bound for the reversal distance

$$d(\pi) \geq b(\pi) - c(\pi)$$ Closing the gap between the reversal distance and this lower bound relies on a graph structure called *hurdle*. It doesn't look there is an intuition or an interpretation for this type of structure. The idea is related to identifying structures that make the rearrangement problem more difficult to solve and in which type of structure we are allowed to perform movements or not. The way these structures are defined depends on the convenience for the solution of specific problems. There is a lot of sightly different definitions for hurdles, but here we are going to explain the structure used by Hannenhalli and Pevzner.

Identifying hurdles depends on some characteristics for gray edges, cycles and how this characteristics are related.

### Orientation of edges and cycles

A gray edge is called oriented when the sum of the positions of the nodes in the permutation vector is even. Otherwise, the edge is unoriented.

Cycles having at least one oriented gray edge are oriented, and unoriented if all gray edges are unoriented.

Unoriented cycles doesn't have a proper inversion, i.e., an inversion that helps to reach the solution of our problem.

### Extension of gray edges

An extension of an edge is the interval given by the positions of its nodes in the permutation vector.

We need to find a characteristic called "interleaving" between gray nodes, which essentially says if two gray nodes overlap (i.e., their extensions overlap), but none of them contains the another one. If $e_1 \in C_1$ and $e_2 \in C_2$ are two gray edges interleaving, we can say $C_1$ and $C_2$ are two cycles interleaving.

At this point, we need to create another structure to save the required information to decide our inversions. This structure is a graph constructed from our cycles.

## Components graph

Lets create a new graph where each node represents a cycle on our breakpoint graph. If two cycles interleaves, we create a link between them:

```{r}
h <- components_graph(g, query_sequence_unsig)

plot(h, edge.width = 4, vertex.size = 20)
```

Each cycle can be oriented or unoriented. So this is a node attribute. Here, blue nodes are unoriented cycles, while orange nodes are oriented cycles. Hence, a component with only blue nodes is an unoriented component.

Now, we need analyze the connected components of this graph. A connected component is oriented if it has at least one oriented node, and unoriented otherwise.

For each unoriented component, lets get the union of the extension of all gray edges. The extremities of this union will be the extension of the unoriented component.

The extension of unoriented components essentially allows us to find what we define by hurdles.

## Hurdles

```{r Counting hurdles and superhurdles}

info <- hurdles_count(g, query_sequence_unsig)

info
```

The extensions of unoriented components are intervals of natural numbers. They can:

-   be contained by another extensions of unoriented components,

-   contain another extensions of unoriented components,

-   none of those above.

These possibilities allow us to classify an unoriented component as a *minimal hurdle* or a (possibly) *greatest hurdle*, with the following rules:

| Contains | Is contained | Minimal hurdle | Greatest hurdle |
|:--------:|:------------:|:--------------:|:---------------:|
|   yes    |     yes      |       no       |       no        |
|   yes    |      no      |       no       |    possibly     |
|    no    |     yes      |      yes       |       no        |
|    no    |      no      |      yes       |       no        |

If there is a possible greatest hurdle, it needs to satisfy the following conditions:

- its extension covers all another hurdles

- there is no gray edge separating hurdles

If there is a greatest hurdle, it is unique. We will write the number of hurdles of a permutation $\pi$ as $h(\pi)$.

## Superhurdles

A hurdle is considered a *superhurdle* if it "protects" another unoriented component which is not a hurdle. This means that, if this hurdle is removed from the graph, the "protected" unoriented component turns into a hurdle.

It is necessary to calculate them to find another required calculation to find the reversal distance, called *fortress*.

```{r}

superhurdles_count(info, g, query_sequence_unsig)

```

## Fortress

A permutation is a *fortress* if the number of hurdles is odd and all hurdles are superhurdles:

$f(\pi) = 1$ if $\pi$ is a fortress,
$f(\pi) = 0$ otherwise.

```{r Is it fortress?}
#analyze if the permutation is a fortress
is_fortress(info)
  
  #return 1 if it is fortress
  #return 0 otherwise
  
```

## Reversal distance

Finally, we can calculate the reversal distance, given by 

$$t(\pi) = b(\pi) - c(\pi) + h(\pi) + f(\pi) $$
# Performing the rearrangement

Clearly, what we want to do is to decrease the number of the reversal distance. Lets say we get a pair of positions to perform an inversion, resulting on the permutation $\pi_2$. It was demonstrated by Hannenhalli and Pevzner that the reversal distance can be decreased by at most 1. Hence, a permutation must be done in order to have

$$t(\pi_2) - t(\pi) = -1$$.

To sort the DNA sequence by inversions, therefore, we search iterativelly along all possible inversions and calculate the parameter above. If some permutation reduces the reversal distance, we perform this reversal. We do this until have our sequence sorted.

```{r Generating simulated scrambling}

# dna_blocks <- 8
# number_inversions <- 5
# 
# #simulating a number of random inversions given by "simulations" in an unsigned sequence s
# simulate_inversion(s, simulations)
# 
# target_sequence <- 1:(2*dna_blocks + 2)
# 
# simulate_inversion_res <- simulate_inversion(target_sequence_unsig, number_inversions)
# 
# positions <- simulate_inversion_res$positions
# query_sequence_unsig <- simulate_inversion_res$sequence 
```

```{r Another cases from the paper}
# #query_sequence <- c(5, 7, 6, 8, 1, 3, 2, 4)
# 
# #query_sequence <- c(2, 4, 3, 5, 7, 6, 8, 1)
# 
# #query_sequence <- c(1, -5, 4, -3, 2)
# 
# #query_sequence_unsig <- sig2unsig(query_sequence)
# 
# #query_sequence_unsig <- c(0,45,46,43,44,1,2,7,8,13,14,11,12,9,10,15,16,5,6,3,4,17,18,23,24,29,30,27,28,25,26,31,32,37,38,35,36,33,34,39,40,21,22,19,20,41,42,47) +1
# 
query_sequence_unsig <- c(0,45,46,43,44,1,2,7,8,13,14,11,12,9,10,32,31,26,25,28,27,30,29,24,23,18,17,4,3,6,5,16,15,37,38,35,36,33,34,39,40,21,22,19,20,41,42,47) + 1

```

```{r Performing the rearrangements}
start_time <- Sys.time()
result <- inversions_rearrangement(query_sequence_unsig)
end_time <- Sys.time()

print(result)

end_time - start_time

```
```{r Sequence from GenomicBreaks}
query_sequence_unsig <- system.file("extdata/NeuCra__PodCom.III__7.gff3.gz", package = "GenomicBreaks") |> load_genomic_breaks(type = 'match') |> head(100) |> bpGraph()

start_time <- Sys.time()
result <- inversions_rearrangement(query_sequence_unsig)
end_time <- Sys.time()

print(result)

end_time - start_time
```

