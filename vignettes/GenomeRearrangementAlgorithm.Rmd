---
title: "GenomeRearrangementAlgorithm"
author: "Bruna Fistarol"
date: "2024-02-06"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Genome Rearrangement Algorithm - Sorting by Reversals

This vignette explains how the algorithm for rearranging by inversions was written, based on Hannenhalli and Pevzner work "Transforming Cabbage into Turnip: Polynomial Algorithm for Sorting Signed Permutations by Reversals", from 1999.

All required functions to sort by reversals are implemented on the following R script:

```{r}
source("InversionAlgorithm.R")
```

## Genome representation

The algorithm works in order to rearrange a numeric sequence by inversions in order to obtain the sorted sequence $1, 2, ..., n$, where $n$ is the number of DNA fragments from a one-to-one relationship of two genomes.

Therefore, to transform a genome into another, we have to define one genome as a sorted sequence $1, 2, ..., n$ (the identity permutation), and the second one as a signed permutation $\pi$ from the first one - Genome Breaks package is able to do this job. A negative number in the sequence means an inverted DNA fragment.

### Transforming a signed sequence into an unsigned sequence

A largely used structure in the case of a signed permutation (which means we have inversions) is representing a fragment as a pair of numbers removing the signal, where we replace each positive element $i$ of $\pi$ by $(2i, 2i+1)$ and each negative element $-i$ of $\pi$ by $(2i+1, 2i)$. We also add two elements $\pi(0)=1$ and $\pi(n+1) = 2n+2$ - these numbers will be useful to identify breakpoints at the beginning and end of the strand. The reason to use this structure is the fact that it is way much better to apply graph approaches. Lets use an example given by the paper:

```{r Defining the genome structure}

p <- c(1, -5, 4, -3, 2)

#transforming a signed permutation into an unsigned permutation to construct the breakpoint graph

p_unsig <- sig2unsig(p)

p_unsig
```
In order to get a sequence of inversions, it is sufficient to type

```{r}
inversions_rearrangement(p_unsig)
```

or

```{r}
inversions_rearrangement(p, unsigned=FALSE)
```
Each line represents the positions of the inversion in the unsigned sequence. 

If you want to check the steps of the algorithm, read the topics below.

### Implementing the inversion operation

Some carry is required when applying operations in this type of representation above. A fragment n will be represented by $2n$ and $2n+1$, hence, numbers in these forms cannot be separated, i.e., an operation needs to start in an even index and finish in an odd index, once we added two extremities in the vector, so any DNA fragment starts in an even index and finishes in an odd index.

```{r}

#perform an inversion of the third fragment
inversion(p_unsig, 6, 7)

```

If we perform some inversion operations, we can sort the genome:

```{r}
inversion(p_unsig, 6, 7) |> inversion(10, 11) |> inversion(4, 11)
```

Our problem is finding these sequence of rearrangements with a minimal number of movements, called *reversal distance*.

## Creating a breakpoint graph



```{r Creating and visualizing a breakpoint graph}

g <- breakpoint_graph(query_sequence_unsig)

E(g)$color <- ifelse(E(g)$color == "black", "black", "gray")

plot(g, edge.color=E(g)$color)
```

We need to find an attribute called "interleaving" between gray nodes, which essentially says if two gray nodes overlap, but none of them contains the another one. With this, we can establish interactions in the graph of connected components.

```{r Interleaving}

#check if two edges interleaves
is_interleaving(query_sequence_unsig, graph_1, graph_2, edge_1, edge_2)

```

# Counting breakpoints and cycles in the breakpoint graph

```{r Count breakpoints and cycles}

#count the number of breakpoints (including artificial extremities)
bp_count(seq)

#count the number of cycles excluding single nodes
cycle_count(g)
```

```{r}
h <- components_graph(g, query_sequence_unsig)

plot(h)
```

# Counting hurdles and superhurdles

```{r Counting hurdles and superhurdles}

info <- hurdles_count(g, query_sequence_unsig)
```

# Finding superhurdles

```{r}

superhurdles_count(info, g, query_sequence_unsig)

```

# Checking if the permutation is a fortress

```{r Is it fortress?}
#analyze if the permutation is a fortress
is_fortress <- function(superhurdles){
  
  if(sum(superhurdles$hurdles)%%2 == 0){
    return(0)
  }
  if(sum(superhurdles$superhurdle) == sum(superhurdles$hurdle)){
    return(1)
  }
  return(0)
  
  #a permutation is a fortress if the number of hurdles is odd and all hurdles are superhurdles
  #return 1 if it is fortress
  #return 0 otherwise
  
}
```

# Performing the rearrangement

```{r Generating unsigned target sequence and simulated scrambling}
dna_blocks <- 8
number_inversions <- 5


#simulating a number of random inversions given by "simulations" in an unsigned sequence s
simulate_inversion(s, simulations)

target_sequence <- 1:dna_blocks 
target_sequence_unsig <- sig2unsig(target_sequence)

simulate_inversion_res <- simulate_inversion(target_sequence_unsig, number_inversions)

positions <- simulate_inversion_res$positions
query_sequence_unsig <- simulate_inversion_res$sequence 
```

```{r Another cases from the paper}
#query_sequence <- c(5, 7, 6, 8, 1, 3, 2, 4)

#query_sequence <- c(2, 4, 3, 5, 7, 6, 8, 1)

#query_sequence <- c(1, -5, 4, -3, 2)

#query_sequence_unsig <- sig2unsig(query_sequence)

#query_sequence_unsig <- c(0,45,46,43,44,1,2,7,8,13,14,11,12,9,10,15,16,5,6,3,4,17,18,23,24,29,30,27,28,25,26,31,32,37,38,35,36,33,34,39,40,21,22,19,20,41,42,47) +1

query_sequence_unsig <- c(0,45,46,43,44,1,2,7,8,13,14,11,12,9,10,32,31,26,25,28,27,30,29,24,23,18,17,4,3,6,5,16,15,37,38,35,36,33,34,39,40,21,22,19,20,41,42,47)+1

```

```{r Performing the rearrangements}

inversions_rearrangement(seq, unsigned=TRUE)
  
```
