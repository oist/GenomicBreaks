---
title: "Genome Rearrangement"
output: html_notebook
editor_options: 
  chunk_output_type: inline
---

# The Genome Rearrangement Problem

General formulation: given two genomes and a set of possible evolutionary events, find a sequence of rearrangements transforming a genome into another.

The diversity of this problem is given by two fundamental questions:

1)  What does "genome" means? Linear or circular? One or more chromosomes?
2)  What "events" are? Translocations, block interchanges, inversions, mutations, indels, transposons (cut and paste or copy and paste)... Can we change fragments between chromosomes?

Finding a solution for the genome rearrangement problem , i.e., the best algorithms, relies on the answer of these questions. But before starting to think about it, we need to have a reasonable data structure to work with.

## How to relate two genomes

The starting point is define a relation between two genomes. Suppose we have a DNA sequence $s$ which we consider as standard (target), where each DNA fragment is represent by a number. Here the toy sequence has 7 DNA fragments

$$
s ~~~ \rightarrow~~~  1~~~  2~~~  3~~~  4~~~  5~~~  6~~~  7
$$

```{r}
s <- c(1, 2, 3, 4, 5, 6, 7)
```

A signed permutation $\pi$ can be represented, for example, by

$$
\pi = [2, 3, -5, -4, -6, 7, 1],
$$

where a negative number means an inversion.

But how can we interpret the permutation?

Our target is the standard sequence. For the first DNA fragment of the query our permutation says

$$
\pi_1 = 2,
$$

which means the first element in the new sequence should be the second element of the original vector

Our example has seven DNA fragments:

$$
\_ ~~~ \_ ~~~ \_ ~~~ \_ ~~~ \_ ~~~ \_ ~~~ \_
$$

As we saw above, the second fragment is located on the first position of the query:

$$
2 ~~~ \_ ~~~ \_ ~~~ \_ ~~~ \_ ~~~ \_ ~~~ \_
$$

Similarly, we have $\pi_2=3$, which means the fragment 3 of the target is located on the second position of the query:

$$
2 ~~~ 3 ~~~ \_ ~~~ \_ ~~~ \_ ~~~ \_ ~~~ \_
$$

Doing this for all positions, we get:

$$
\pi(s) ~~~ \rightarrow ~~~ 2~~~  3~~~  -5~~~  -4~~~  -6~~~  7~~~  1
$$

which is what we have on the query sequence when we make an alignment if we assume the target is a standard sequence. In this case, it is exactly the same as the permutation itself. But this only happens if we are permuting a standard sequence.

R has a function called *order*, which receives a vector and, for each position, tells where is the number that should be in that position. This is useful to get the permutation vector given the query sequence in order to obtain the target sequence. However, this function does not work in a signed permutation, once it sees inversions as negative numbers.

This could be solved taking the numbers as positives,

$$
\pi_{seq}(s) ~~~ \rightarrow ~~~ 2~~~  3~~~  5~~~  4~~~  6~~~  7~~~  1 \\
$$

```{r}
pi_s <-  c(2, 3, -5, -4, -6, 7, 1)
pi_seq_s <- abs(pi_s)
pi <- order(pi_seq_s)
pi
```

and putting the signal back on the numbers relative to negative indexes - in this case, 4, 5, and 6 are negative indexes on $\pi(s)$, so these number will be negative on $\pi$.

```{r}
neg_indices <- which(pi_s < 0)
neg_elements <- pi %in% neg_indices
pi = pi* ifelse(neg_elements, -1, 1)
pi
```

we got the permutation vector that transforms the query on the target.

Is it possible to compare two genomes having their order. But permutation vectors are pieces of the solution for the genome rearrangement problem which describe the changes in a genome in order to get the another genome.

## Transforming a signed sequence into an unsigned sequence

A largely used structure in the case of a signed permutation (which means we have inversions) is representing a fragment as a pair of numbers removing the signal, where we replace each positive element $i$ of $\pi$ by $(2i, 2i+1)$ and each negative element $-i$ of $\pi$ by $(2i+1, 2i)$. We also add two elements $\pi(0)=1$ and $\pi(n+1) = 2n+2$, where $n$ is the number of DNA fragments - these numbers will be useful to identify breakpoints at the beggining and end of the strand. The reason to use this structure is the fact that it is way much better to apply graph approaches for solving the genome rearrangement problem, instead of using signals to represent an inversion. Let's represent our example:

```{r # transform the input in an unsigned mapping and add two extremities 1 and 2n+2, where n is the number of dna fragments}

sig2unsig <- function(p){ 
  p_unsig <- sapply(p, function(i) { 
    if (i>0){ c( 2*i,     2*i + 1) } 
    else    { c(-2*i + 1, -2*i   ) }
    })
  c(1, p_unsig, 2*length(p)+2)
  }

```

```{r}
pi_s_unsig=sig2unsig(pi_s)
pi_s_unsig
```

Some carry is required when applying operations in this type of representation. A fragment n will be represented by $2n$ and $2n+1$, hence, numbers in these forms cannot be separated, i.e., an operation needs to start in an even index and finish in an odd index, once we added two extremities in the vector, so any DNA fragment starts in an even index and finishes in an odd index.

How do we get now if we ask the order?

```{r}
order(pi_s_unsig)
```

which is exactly the same thing if we construct an unsigned permutation.

```{r}
sig2unsig(pi)
```

No surprises. But things get easy when we don't need to worry about signals.

Another reason to get unsigned sequences is the analysis of lagged differences between them, which able us to identify patterns like double inversions overlapping and nested inversions.

## Genomic Rearrangements

Lets implement some operations:

```{r implementing genome rearrangement operations}

#these functions still dont handle all error cases (out of range inputs)

#perform a translocation
translocation <- function(seq, i, j, k){
  k=k+k%%2
  if (i%%2==0 & j%%2==1 & i<j & (i>k | j<k)){
    if (i>k){
      c(seq[1:(k-1)], seq[i:j], seq[k:(i-1)], seq[-(1:(j+1))])}
    else {
      c(seq[1:i-1], seq[(j+1):(k-1)], seq[i:j], seq[-(1:(k-1))])  
      }
  }
  else {
    seq
  }
}

#perform an inversion
inversion <- function(seq, i, j){
      if  (i%%2!=0 | j%%2!=1)   stop("Invalid operation. 
                                      Insert an even starting and an odd ending")
      c(seq[1:(i-1)], seq[j:i], seq[-(1:j)])
  }

#perform block interchanges
block_interchange <- function(seq, i, j, k, l){
  if ((k%%2==0)==((i%%2)+1) & ((l%%2)==1)==((j%%2)) & i<j & j<k & k<l){
    c(seq[1:(i-1)], seq[k:l], if(j==(k-1)) NULL else seq[(j+1):(k-1)], seq[i:j], seq[-(1:l)])
  }
  else stop("Invalid operation. Insert non overlapping blocks with an even starting and an odd ending for both.")
}
```

## Lagged differences of unsigned vectors

Once a DNA fragment is represented on the vector `s_unsig` by two consecutive numbers and two extra extremities, we can expect the following structure from the lagged difference $l$:

$$
l = [\pm a_1, ~~\pm1,~~ \pm a_2, ~~\pm1, ~~\pm a_3, ~~\cdots,~~ \pm1,~~ \pm a_{n+1}],
$$

where $\pm$ indicates if the sequence is inverted (negative) or not (positive), and $a_i \in \mathbb{N}$, $i\in (1, 2, \cdots, n+1)$, represents if there is a break-point or not. A break-point is present when $|a_i| \neq 1$.

Therefore, we can try to characterize the signatures of different structures created by rearrangements.

### Co-linearity

Lets check how a lagged difference looks in an ordered sequence:

```{r}
s_unsig <- sig2unsig(s)
diff(s_unsig)
```

The function `diff` is such that the computed result is equal to the successive differences `s[2:(2n+2)] - s[1:(2n+1)]`, therefore, it is expected that a co-linear sequence has a sequence of $1$'s as its lagged difference.

Another case of co-linearity, when the entire strand is inverted:

```{r}
(-7:-1) |>  sig2unsig() |> diff()
```

### Simple inversion

Lets perform inversions in our standard strain $s$:

```{r}
s_inv <-  inversion(s_unsig, 4, 7)
s_inv
```

And its lagged difference:

```{r}
diff(s_inv)
```

We can identify the interrupted co-linearity by the number $4$, which characterizes a break-point. The $-1$'s means an inverted sequence, but also the co-linearity inside the inverted sequence (the $-1$ in the middle).

Another examples:

```{r}
s_unsig |> inversion(4,5)  |> diff()
s_unsig |> inversion(4,9)  |> diff()
s_unsig |> inversion(4,11)  |> diff()
```

### Overlapping double inversions

Lets perform inversions in order to have an overlapping between them. What a lagged difference can tell about the signature of a double inversion?

```{r}
s_unsig |> inversion(4, 7) |> inversion(6, 9) |> diff() #first on the left
s_unsig |> inversion(6, 9) |> inversion(4, 7) |> diff() #first on the right
```

Negative break-points in this case can tell us that such region has been moved at least twice. Hence, a double inversion signature is described by

$$
[a_{i}, ~~~~ -1, ~~~~ a_{i+1}, ~~~~ -1,  ~~~~ -a_{i+2}, ~~~~ 1, ~~~~ a_{i+3}]
$$

or

$$
[a_{i}, ~~~~ 1, ~~~~ -a_{i+1}, ~~~~ -1,  ~~~~ a_{i+2}, ~~~~ -1, ~~~~ a_{i+3}]
$$

depending on the order that the inversions happens.

Now lets find the same patterns in a total inverted sequence.

```{r}
sig2unsig(-7:-1) |> inversion(4, 7) |> inversion(6, 9) |> diff() #first on the left
sig2unsig(-7:-1) |> inversion(6, 9) |> inversion(4, 7) |> diff() #first on the right
```

Note that the breakpoints at the extremities are from the entire inversion at the beginning. The found patterns for double inversions are:

$$
[-a_{i}, ~~~~ 1, ~~~~ -a_{i+1}, ~~~~ 1,  ~~~~ a_{i+2}, ~~~~ -1, ~~~~ -a_{i+3}]
$$

or

$$
[-a_{i}, ~~~~ -1, ~~~~ a_{i+1}, ~~~~ 1,  ~~~~ -a_{i+2}, ~~~~ 1, ~~~~ -a_{i+3}]
$$

Which are exactly the same as before, but with opposite signals.

### Nested inversions

```{r}

s_inv_nested <- inversion(s_unsig, 4, 9) |> inversion(6, 7) |> diff()

#or the opposite order

s_inv_nested2 <- inversion(s_unsig, 6, 7) |> inversion(4, 9) |> diff()

s_inv_nested
s_inv_nested2
```

A nested inversion has the following pattern in the plus strand:

$$
[a_i, ~~~~ -1, ~~~~ -a_{i+1}, ~~~~ 1,  ~~~~ -a_{i+2}, ~~~~ -1, ~~~~ a_{i+3}]
$$

As we saw on the double inversion case, the pattern on the minus strand is the same, but with opposite signals:

$$
[-a_i, ~~~~ 1, ~~~~ a_{i+1}, ~~~~ -1,  ~~~~ a_{i+2}, ~~~~ 1, ~~~~ -a_{i+3}]
$$

## Searching for patterns

In order to standardize the break-points, we can replace them by a single number (not 1 or zero), which can be positive or negative.

```{r}
diff_s_inv_nested <- diff(s_inv_nested)
diff_s_inv_nested[diff_s_inv_nested > 1] <- 2
diff_s_inv_nested[diff_s_inv_nested < -1] <- -2

nested_pattern <- c(2, -1, -2, 1, -2, -1, 2) #just works if the sequence is coalescent - but there is a function to do it on gb objects
```

```{r}
library(zoo)
rearrangement_search <- function(seq, pattern) {
  pattern_length <- length(pattern)
  matches <- rollapply(seq, pattern_length, function(window) all(window == pattern), align = "left")
  which(matches)
}
```

Double inversion example from GBreaks

```{r}
seq <- asSignedPermutation(exampleGB)
seq_unsig <- sig2unsig(seq)
diff_seq <- diff(seq_unsig)

diff_seq[diff_seq > 1] <- 2
diff_seq[diff_seq < -1] <- -2

double_inv_pattern1 <- c(2, -1, 2, -1, -2, 1, 2)
double_inv_pattern2 <- c(2, 1, -2, -1, 2, -1, 2)

rearrangement_search(diff_seq, double_inv_pattern1)
rearrangement_search(diff_seq, double_inv_pattern2) #found it
```
