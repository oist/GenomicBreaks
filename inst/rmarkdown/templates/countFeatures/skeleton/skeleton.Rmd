---
title: "Count features"
author: "Charles Plessy"
date: "02/07/2023"
output: 
  html_document: 
    keep_md: yes
params:
  alnFile: "/absolute/path/to/your/file"
  matchType: "match_part or match depending on GFF file format"
  prefix: "PrefixForOutputFileNames"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(progress = TRUE, verbose = TRUE, root.dir = system2("pwd", stdout = TRUE))
```

```{r load_libraries}
library("GenomicBreaks") |> suppressPackageStartupMessages()
library("ggplot2")       |> suppressPackageStartupMessages()
```

How to use this Rmarkdown template:

It is essential to set `R_LIBS_USER` to an empty value, otherwise `R` will
attempt to load packages from the user's library, which were compiled in a
different environment than the GenomicBreaks Singularity image.

Example command

```
R_LIBS_USER='' R -e 'rmarkdown::render("thisTemplate.Rmd", output_file = "./outFile.html", params = list(alnFile = "/path/do/dir/with/alignment/files"))'
```

Load data
---------

```{r load_data}
# Display parameters
params

# Load the alignment in a GBreaks object
gb <-load_genomic_breaks(params$alnFile, type = params$matchType)
```

Coalesce contigs
----------------

```{r coalesce_contigs}
coa <- coalesce_contigs(gb)
makeOxfordPlots(coa) + ggtitle(params$alnFile)
```

### Extract information

We divide the genome into four categories: _isolated alignments_, _breakpoint
regions_, _colinear alignments_ and _bridge regions_.

_Colinear alignments_ are defined by the colinearity relationship computed
in `?flagColinearAlignments`.  _Bridge regions_ separate alignments that are
colinear to each other.  _Isolated alignments_ have no colinear counterparts
and _breakpoint regions_ are the remaining intervals.  _Colinear regions_ 
(or _chains_) are the union of _colinear alignments_ and _bridge regions_.

As Bioconductor's `gaps()` function returns also the unaligned sequences between
the start/end of chromosome and the first/last block, we use the `?cleanGaps`
function that removes them before returning the object.
   
```{r clean_gaps}
isol <- gb[gb %in% coa]
coli <- gb[!gb %in% coa]
bri <- if (length(filterColinearRegions(flagColinearAlignments(gb), rename = FALSE)) == 0) {
  GBreaks()
} else {
  bridgeRegions(gb)
}
# Can be reverted once #20 is fixed in the main branch
# bri  <- bridgeRegions(gb)
brk  <- cleanGaps(coa)
brk_q <- cleanGaps(coa$query)
```

Inversions
----------

```{r study_inversions}
coa <- flagInversions(coa)
sum(coa$inv)
inv <- filterInversions(coa)
head(inv, 11)
```

Translocations
--------------

Patterns that can be described as translocations in the target genome.

```{r study_translocations}
coa <- flagTranslocations(coa)
sum(coa$tra)
tra <- filterTranslocations(coa)
head(tra, 11)
```

Width plot

```{r plot_widths, fig.height=12, dev=c('svg', 'png')}
# Need to wrap in a function to handle empty GRanges objects...
width2df <- function(what, gr) {
  if (length(gr) == 0) {
    data.frame(what = what, width = 0)
  } else { 
    data.frame(what = what, width = width(gr))
  }
}

rbind(
  width2df(what = "isol_aln", gr = isol),
  width2df(what = "breakpoint_regions",   gr = brk),
  width2df(what = "colinear_aln", gr = coli),
  width2df(what = "colinear_region", gr = coa),
  width2df(what = "bridge", gr = bri),
  width2df(what = "translocations", gr = tra),
  width2df(what = "inversions", gr = inv)
) |> ggplot() +
  aes(width) +
  geom_histogram() +
  scale_x_log10() +
  facet_wrap(~what, ncol = 1, scales = "free_y")
```



Calculate numbers and prepare them for export in a YAML file
------------------------------------------------------------

```{r count_features}
customSummary <- function(x, pasteToNames=NULL) {
  s <- summary(x)
  names(s) <- c("Min", "Q1", "Median", "Mean", "Q3", "Max")
  s["L50"]     <- weighted.mean(x, as.numeric(x)) # as.num to avoid integer overflow
  s["Total"]   <- sum(x)
  s["N"]       <- length(x)
  s <- as.list(s)
  names(s) <- paste0(pasteToNames, '_', names(s))
  s
}

summaryWidth <- function(gb, pasteToNames=NULL) {
  w <- if(length(gb) == 0) {
      0
    } else {
      width(gb)
    }
  customSummary(w, pasteToNames)
}

gb$mismatches <- (width(gb) + width(gb$query) - gb$aLength - gb$matches)

report <- list() |>
  c(customSummary(gb$aLength, "aligned_length")) |>
  c(customSummary(score(gb),  "aligned_scores")) |>
  c(customSummary(gb$matches,                         "matches_number"))     |>
  c(customSummary(gb$mismatches,                      "mismatches_number"))  |>
  c(customSummary(gb$aLength - width(gb),             "gaps_target"))       |>
  c(customSummary(gb$aLength - width(gb$query),       "gaps_query"))        |>
  c(customSummary(100 * gb$matches / gb$aLength,      "percent_identity_") ) |>
  c(customSummary(100 * gb$matches / width(gb),       "matching_target"))    |>
  c(customSummary(100 * gb$matches / width(gb$query), "matching_query"))     |>
  c(percent_similarity_compat = 1 - sum(gb$mismatches) / sum(width(gb))) |>
  c(customSummary(1 - gb$mismatches / width(gb), "percentSim_compat"))  |> # To reproduce older figures
  c(summaryWidth(gb,         "aligned_target"))      |>
  c(summaryWidth(gb$query,   "aligned_query"))       |>
  c(summaryWidth(coa,        "chain_target"))        |>
  c(summaryWidth(coa$query,  "chain_query"))         |>
  c(summaryWidth(coli,       "collinear_target"))    |>
  c(summaryWidth(coli$query, "collinear_query"))     |>
  c(summaryWidth(isol,       "isolated_target"))     |>
  c(summaryWidth(isol$query, "isolated_query"))      |>
  c(summaryWidth(bri,        "bridge_target"))       |>
  c(summaryWidth(bri$query,  "bridge_query"))        |>
  c(summaryWidth(brk,        "break_target"))        |>
  c(summaryWidth(brk_q,      "break_query"))         |>
  c(summaryWidth(inv,        "inverted_target"))     |>
  c(summaryWidth(inv$query,  "inverted_query"))      |>
  c(summaryWidth(tra,        "translocated_target")) |>
  c(summaryWidth(tra$query,  "translocated_query"))  |>
  c(guessed_target_length = sum(guessSeqLengths(gb))) |>
  c(guessed_query_length =  sum(guessSeqLengths(gb$query))) |>
  c(index_synteny_target = synteny_index(gb)) |>
  c(index_synteny_query  = synteny_index(swap(gb))) |>
  c(index_correlation_target = correlation_index(gb)) |>
  c(index_correlation_query = correlation_index(swap(gb))) |>
  c(index_GOCvicinity4_target = GOC(gb, vicinity = 4)) |> # Default as of today.  Does not make much sense on nucleotide sequences?
  c(index_GOCvicinity4_query = GOC(swap(gb), vicinity = 4)) |> # Default as of today.  Does not make much sense on nucleotide sequences?
  c(index_strandRand_target = strand_randomisation_index(gb)) |>
  c(index_strandRand_query = strand_randomisation_index(swap(gb)))
```

Export the results to a YAML file.

```{r export_results}
yaml <- yaml::as.yaml(report)
yaml::write_yaml(yaml, paste0(params$prefix, ".yaml"))
cat(yaml)
```
