% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/orderQuerySeqLevels.R
\name{orderQuerySeqLevels}
\alias{orderQuerySeqLevels}
\alias{orderQuerySeqLevels_DF_GR}
\title{Ordering permutation for \emph{query} relative to \emph{target}}
\usage{
orderQuerySeqLevels(gb)

orderQuerySeqLevels_DF_GR(DF, gr)
}
\arguments{
\item{gb}{A \code{\link{GBreaks}} object that has only one sequence level in use on the
\emph{target} genome.}

\item{DF}{A \code{\link[S4Vectors:DataFrame-class]{S4Vectors::DataFrame}} object representing the \emph{target} genome.}

\item{gr}{A \code{\link[GenomicRanges:GRanges-class]{GenomicRanges::GRanges}} object representing the \emph{query} genome.}
}
\value{
Returns an integer vector of order permutations for the sequence
levels of the \emph{query} genome.
}
\description{
Computes a permutation which rearranges the sequence levels of the \emph{query}
genome so that it reflects the order in which we see the matches on a
pairwise plot.
}
\details{
This is done by computing the average midpoint position of the \emph{query} ranges
on the \emph{target} genome for each seqlevel, matched by the width of the
\emph{target} ranges, so that long matches have more importance.  This avoids
spurious ordering due to short matches in the subtelomeric regions.
}
\note{
The order only makes sense relative to a single sequence level of the
\emph{target} genome, so the function will stop with error if there was more
than one.
}
\examples{
gb       <- GRanges(c("chr1:101-180:+", "chr1:201-300:+",  "chr1:320-400:+"))
gb$query <- GRanges(c( "cgt8:1-100",      "ctg3:1-100",    "ctg5:1-100"))
gb <- GBreaks(gb)
# Sort alphabetically as if they were inherited from a BSgenome object
seqlevels(gb$query) <- c("ctg3", "ctg5", "cgt8")
seqlevels(gb$query)
# Sort by match positions on the target genome.
seqlevels(gb$query) <- seqlevels(gb$query)[orderQuerySeqLevels(gb)]
seqlevels(gb$query)

}
\author{
Charles Plessy
}
\concept{seqlevel functions}
