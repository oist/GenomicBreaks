% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/longestMatchesInTarget.R
\name{longestMatchesInTarget}
\alias{longestMatchesInTarget}
\title{Find longest matches from target to query genome.}
\usage{
longestMatchesInTarget(gb, min.width = 10000, min.matches = 2)
}
\arguments{
\item{gb}{A \code{GBreaks} object}

\item{min.width}{Minimum width of a match (on the query genome) for being
considered.}

\item{min.matches}{Discard query sequences that have fewer longest matches than
\code{min.matches} on the target.  Default is 2, so that only results relevant
to chaining genomes are kept.}
}
\value{
Returns a \code{\link{GRangesList}} object containing one \code{\link{GBreaks}} object per
sequence on the query genome.
}
\description{
Using a \code{\link{GBreaks}} object representing the alignment of a \emph{query} genome
on a \emph{target} genome, finds the longest match of each sequence level
(representing contigs, scaffolds, etc.) of the \emph{query} on the \emph{target}.
}
\details{
Each sequence of the \emph{query} is represented only once in the output, but
sequences of the \emph{target} genome can be represented multiple times if they
are the longest match of multiple \emph{query} genome sequences.  When the \emph{target}
genome is more contiguous than the \emph{query} genome, and if there are no
major structural variations between them, this will reveal arrangements of
colinear sequences in the query genome.

For a more compact version of the results, the output of this function can be
piped to \code{strandNames(query = TRUE)}.
}
\examples{
exampleColinear3
exampleColinear3 |> longestMatchesInTarget(min.width = 0, min.matches = 1)

}
\seealso{
Other scaffolding functions: 
\code{\link{mergeSeqLevels}()},
\code{\link{scaffoldByFlipAndMerge}()},
\code{\link{strandNames}()}
}
\author{
Charles Plessy
}
\concept{scaffolding functions}
