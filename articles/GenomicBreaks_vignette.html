<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GenomicBreaks Vignette • GenomicBreaks</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="GenomicBreaks Vignette">
<meta property="og:description" content="GenomicBreaks">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">GenomicBreaks</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.2.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/GenomicBreaks_vignette.html">GenomicBreaks Vignette</a>
    </li>
  </ul>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/oist/GenomicBreaks/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="GenomicBreaks_vignette_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>GenomicBreaks Vignette</h1>
                        <h4 class="author">Charlotte West</h4>
                        <h4 class="author">Charles Plessy</h4>
            
            <h4 class="date">06 September, 2021</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/oist/GenomicBreaks/blob/master/vignettes/GenomicBreaks_vignette.Rmd"><code>vignettes/GenomicBreaks_vignette.Rmd</code></a></small>
      <div class="hidden name"><code>GenomicBreaks_vignette.Rmd</code></div>

    </div>

    
    
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">knitr</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/knitr/man/opts_chunk.html">opts_chunk</a></span><span class="op">$</span><span class="fu">set</span><span class="op">(</span>cache <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="fu">knitr</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/knitr/man/opts_knit.html">opts_knit</a></span><span class="op">$</span><span class="fu">set</span><span class="op">(</span>verbose <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p>The <em>GenomicBreaks</em> R package contains tools for visualising and analysing characteristics associated with <em>breakpoints</em> between pairs of <em>genomes</em>.</p>
<div id="load-pacakges" class="section level2">
<h2 class="hasAnchor">
<a href="#load-pacakges" class="anchor"></a>Load pacakges</h2>
<p>Core packages that provide functions we use a lot.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://github.com/oist/GenomicBreaks">'GenomicBreaks'</a></span><span class="op">)</span></code></pre></div>
<pre><code>## Loading required package: GenomicRanges</code></pre>
<pre><code>## Loading required package: stats4</code></pre>
<pre><code>## Loading required package: BiocGenerics</code></pre>
<pre><code>## Loading required package: parallel</code></pre>
<pre><code>## 
## Attaching package: 'BiocGenerics'</code></pre>
<pre><code>## The following objects are masked from 'package:parallel':
## 
##     clusterApply, clusterApplyLB, clusterCall, clusterEvalQ,
##     clusterExport, clusterMap, parApply, parCapply, parLapply,
##     parLapplyLB, parRapply, parSapply, parSapplyLB</code></pre>
<pre><code>## The following objects are masked from 'package:stats':
## 
##     IQR, mad, sd, var, xtabs</code></pre>
<pre><code>## The following objects are masked from 'package:base':
## 
##     anyDuplicated, append, as.data.frame, basename, cbind, colnames,
##     dirname, do.call, duplicated, eval, evalq, Filter, Find, get, grep,
##     grepl, intersect, is.unsorted, lapply, Map, mapply, match, mget,
##     order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank,
##     rbind, Reduce, rownames, sapply, setdiff, sort, table, tapply,
##     union, unique, unsplit, which.max, which.min</code></pre>
<pre><code>## Loading required package: S4Vectors</code></pre>
<pre><code>## 
## Attaching package: 'S4Vectors'</code></pre>
<pre><code>## The following objects are masked from 'package:base':
## 
##     expand.grid, I, unname</code></pre>
<pre><code>## Loading required package: IRanges</code></pre>
<pre><code>## Loading required package: GenomeInfoDb</code></pre>
<pre><code>## </code></pre>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/message.html">suppressPackageStartupMessages</a></span><span class="op">(</span><span class="op">{</span>
  <span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://bioconductor.org/packages/BSgenome">'BSgenome'</a></span><span class="op">)</span>
  <span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://bioconductor.org/packages/GenomicFeatures">'GenomicFeatures'</a></span><span class="op">)</span>
  <span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://bioconductor.org/packages/GenomicRanges">'GenomicRanges'</a></span><span class="op">)</span>
  <span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="st"><a href="https://ggplot2.tidyverse.org">'ggplot2'</a></span><span class="op">)</span>
<span class="op">}</span><span class="op">)</span></code></pre></div>
<div id="bsgenome-packages" class="section level3">
<h3 class="hasAnchor">
<a href="#bsgenome-packages" class="anchor"></a>BSgenome packages</h3>
<p>The Oikopleura BSgenome packages are distributed in a drat directory hosted on GitHub ((oist/plessy_oikgenomes_drat)[<a href="https://oist.github.io/plessy_oikgenomes_drat/" class="uri">https://oist.github.io/plessy_oikgenomes_drat/</a>]).</p>
<p>To install them:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># # Chromosome assemblies</span>
<span class="co"># install.packages("BSgenome.Odioica.local.OKI2018.I69", repos="https://oist.github.io/plessy_oikgenomes_drat/")</span>
<span class="co"># install.packages("BSgenome.Odioica.local.OSKA2016v1.9", repos="https://oist.github.io/plessy_oikgenomes_drat/")</span>
<span class="co"># install.packages("BSgenome.Odioica.local.Bar2.p4", repos="https://oist.github.io/plessy_oikgenomes_drat/")</span>
<span class="co"># </span>
<span class="co"># # Less contiguous genomes</span>
<span class="co"># install.packages("BSgenome.Odioica.local.Odioica.reference.v3.0", repos="https://oist.github.io/plessy_oikgenomes_drat/")</span>
<span class="co"># install.packages("BSgenome.Odioica.local.AOM.5", repos="https://oist.github.io/plessy_oikgenomes_drat/")</span>
<span class="co"># install.packages("BSgenome.Odioica.local.KUM.M3", repos="https://oist.github.io/plessy_oikgenomes_drat/")</span></code></pre></div>
<p>Other BSgenome packages are distributed by Bioconductor</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># BiocManager::install("BSgenome.Hsapiens.UCSC.hg38")</span>
<span class="co"># BiocManager::install("BSgenome.Ptroglodytes.UCSC.panTro6")</span></code></pre></div>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># # These will need to be installed by the user</span>
<span class="co"># library("BSgenome.Odioica.local.OKI2018.I69")</span>
<span class="co"># library("BSgenome.Odioica.local.OSKA2016v1.9")</span>
<span class="co"># library("BSgenome.Odioica.local.Bar2.p4")</span>
<span class="co"># library("BSgenome.Odioica.local.KUM.M3")</span>
<span class="co"># library("BSgenome.Odioica.local.AOM.5")</span>
<span class="co"># library("BSgenome.Odioica.local.Odioica.reference.v3.0")</span>
<span class="co"># </span>
<span class="co"># genomes &lt;- SimpleList(</span>
<span class="co">#   # Chromosome assemblies</span>
<span class="co">#   Oki = OKI2018_I69, Osa = OSKA2016v1.9, Bar = Bar2_p4,</span>
<span class="co">#   # Less contiguous assemblies</span>
<span class="co">#   Kum = KUM_M3, Aom = AOM_5, Nor = OdB3)</span>
<span class="co"># </span>
<span class="co"># ## Genome lengths</span>
<span class="co"># (genome.lengths &lt;- sapply(genomes, \(g) sum(seqlengths(seqinfo(g)))))</span>
<span class="co"># </span>
<span class="co"># ## Genome average AT content</span>
<span class="co"># (genomes.AT &lt;- sapply(genomes, \(g)</span>
<span class="co">#   weighted.mean(letterFrequency(getSeq(g), "AT", as.prob = TRUE), seqlengths(g))))</span></code></pre></div>
</div>
</div>
<div id="load-data" class="section level2">
<h2 class="hasAnchor">
<a href="#load-data" class="anchor"></a>Load data</h2>
<div id="genome-annotations-" class="section level3">
<h3 class="hasAnchor">
<a href="#genome-annotations-" class="anchor"></a>Genome annotations.</h3>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># annots &lt;- SimpleList()</span>
<span class="co"># </span>
<span class="co"># gff2txdb &lt;- function(file, genome) {</span>
<span class="co">#   tx &lt;- rtracklayer::import.gff3(file)</span>
<span class="co">#   tx &lt;- GRanges(tx, seqinfo = seqinfo(genome))</span>
<span class="co">#   tx &lt;- GenomicFeatures::makeTxDbFromGRanges(tx)</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># annots$Oki &lt;- gff2txdb("Annotations/OKI2018_I69.v2/OKI2018_I69.v2.gm.gff", OKI2018_I69)</span>
<span class="co"># annots$Kum &lt;- gff2txdb("Annotations/KUM-M3-7f/KUM-M3-7f.gm.gff", KUM_M3)</span>
<span class="co"># annots$Osa &lt;- gff2txdb("Annotations/OSKA2016v1.9/OSKA2016v1.9.gm.gff",     OSKA2016v1.9)</span>
<span class="co"># annots$Bar &lt;- gff2txdb("Annotations/Bar2_p4.Flye/Bar2_p4.Flye.gm.gff", Bar2_p4)</span>
<span class="co"># annots$Aom &lt;- gff2txdb("Annotations/AOM-5-5f/AOM-5-5f.gm.gff", AOM_5)</span></code></pre></div>
</div>
<div id="long-and-short-arms-" class="section level3">
<h3 class="hasAnchor">
<a href="#long-and-short-arms-" class="anchor"></a>Long and short arms.</h3>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># OKI_longShort &lt;- rtracklayer::import.gff3(system.file("extdata/OKI2018_I69.arms.gff3", package = "GenomicBreaks"))</span>
<span class="co"># OKI_longShort &lt;- GRanges(OKI_longShort, seqinfo = seqinfo(OKI2018_I69), strand = "*")</span></code></pre></div>
</div>
<div id="genomicbreaks-object" class="section level3">
<h3 class="hasAnchor">
<a href="#genomicbreaks-object" class="anchor"></a>GenomicBreaks object</h3>
<p>Let’s load data from genome alignments, copied in the <code>Oidioi_pairwise_v3</code> directory.</p>
<p>Pairwise genome alignments are loaded in <code>GBreaks</code> objects that wrap the <code>GRanges</code> class. By convention, we write that the <em>query</em> genome (the one that was provided as a FASTA file) is aligned to the <em>target</em> genome (the one that was indexed by the aligner). The <em>target</em> genome (on the left) is the main part of the object, and the <em>query</em> genome information (right) is contained in the metadata columns (<code>mcols</code>) of the structure. Information on contig or scaffold length is loaded from <code>BSgenome</code> objects, from which <code>seqinfo</code> data is extracted and passed to the <code>GRanges</code>. By convention, strand information of the alignment is held by the <em>target</em> <code>GRanges</code>, and the <em>query</em> <code>GRanges</code> are strandless. The objects are sorted by <code>seqname</code> first.</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># gbs &lt;- SimpleList()</span>
<span class="co"># load_genomic_breaks_ &lt;- function(file, genomeT, genomeQ, longShort) {</span>
<span class="co">#   gb &lt;- load_genomic_breaks(file, genomeT,  genomeQ)</span>
<span class="co">#   gb$Type &lt;- mcols(longShort)[findOverlaps(gb, longShort) |&gt; subjectHits(), "Type"]</span>
<span class="co">#   gb</span>
<span class="co"># }</span>
<span class="co"># gbs$Oki_Osa &lt;- load_genomic_breaks_("Oidioi_pairwise_v3/OKI2018_I69_1.0__OSKA2016v1.9.gff.gz", OKI2018_I69,  OSKA2016v1.9, OKI_longShort)</span>
<span class="co"># gbs$Oki_Bar &lt;- load_genomic_breaks_("Oidioi_pairwise_v3/OKI2018_I69_1.0__Bar2_p4.gff.gz",      OKI2018_I69,  Bar2_p4,      OKI_longShort)</span>
<span class="co"># gbs$Oki_Kum &lt;- load_genomic_breaks_("Oidioi_pairwise_v3/OKI2018_I69_1.0__KUM-M3-7f.gff.gz",    OKI2018_I69,  KUM_M3,       OKI_longShort)</span>
<span class="co"># gbs$Oki_Aom &lt;- load_genomic_breaks_("Oidioi_pairwise_v3/OKI2018_I69_1.0__AOM-5-5f.gff.gz",     OKI2018_I69,  AOM_5,        OKI_longShort)</span>
<span class="co"># gbs$Oki_Nor &lt;- load_genomic_breaks_("Oidioi_pairwise_v3/OKI2018_I69_1.0__OdB3.gff.gz",         OKI2018_I69,  OdB3,         OKI_longShort)</span>
<span class="co"># </span>
<span class="co"># gbs$Osa_Oki &lt;- load_genomic_breaks("Oidioi_pairwise_v3/OSKA2016v1.9__OKI2018_I69_1.0.gff.gz", OSKA2016v1.9, OKI2018_I69)</span>
<span class="co"># gbs$Osa_Bar &lt;- load_genomic_breaks("Oidioi_pairwise_v3/OSKA2016v1.9__Bar2_p4.gff.gz",         OSKA2016v1.9, Bar2_p4)</span>
<span class="co"># gbs$Osa_Kum &lt;- load_genomic_breaks("Oidioi_pairwise_v3/OSKA2016v1.9__KUM-M3-7f.gff.gz",       OSKA2016v1.9, KUM_M3)</span>
<span class="co"># gbs$Osa_Aom &lt;- load_genomic_breaks("Oidioi_pairwise_v3/OSKA2016v1.9__AOM-5-5f.gff.gz",        OSKA2016v1.9, AOM_5)</span>
<span class="co"># gbs$Osa_Nor &lt;- load_genomic_breaks("Oidioi_pairwise_v3/OSKA2016v1.9__OdB3.gff.gz",            OSKA2016v1.9, OdB3)</span>
<span class="co"># </span>
<span class="co"># gbs$Bar_Oki &lt;- load_genomic_breaks("Oidioi_pairwise_v3/Bar2_p4__OKI2018_I69_1.0.gff.gz",      Bar2_p4,     OKI2018_I69)</span>
<span class="co"># gbs$Bar_Osa &lt;- load_genomic_breaks("Oidioi_pairwise_v3/Bar2_p4__OSKA2016v1.9.gff.gz",         Bar2_p4,     OSKA2016v1.9)</span>
<span class="co"># gbs$Bar_Kum &lt;- load_genomic_breaks("Oidioi_pairwise_v3/Bar2_p4__KUM-M3-7f.gff.gz",            Bar2_p4,     KUM_M3)</span>
<span class="co"># gbs$Bar_Aom &lt;- load_genomic_breaks("Oidioi_pairwise_v3/Bar2_p4__AOM-5-5f.gff.gz",             Bar2_p4,     AOM_5)</span>
<span class="co"># gbs$Bar_Nor &lt;- load_genomic_breaks("Oidioi_pairwise_v3/Bar2_p4__OdB3.gff.gz",                 Bar2_p4,     OdB3)</span>
<span class="co"># </span>
<span class="co"># gbs$Osa_Oki</span>
<span class="co"># gbs$Osa_Oki$query</span></code></pre></div>
<p>In the example displayed above, the object contains the pairwise alignment between genomes of two dioceous <em>Oikopleura</em> individuals; one from the Osaka assembly <code>OSKA2016</code> (<em>target</em>) and one from the Okinawa assembly <code>OKI2018_I69</code> (<em>query</em>).</p>
</div>
</div>
<div id="breakpoints-and-alignment-stops" class="section level2">
<h2 class="hasAnchor">
<a href="#breakpoints-and-alignment-stops" class="anchor"></a>Breakpoints and alignment stops</h2>
<p>Let us define an <strong>alignment stop</strong> to be a position defined in either the <em>target</em> or <em>query</em> genome, where an alignment begins or ends. Looking at the first line in the <code>Osa_Oki</code> object above, <code>Chr1</code> positions 1535 and 1751 of the <em>target</em> would be defined as alignment stops. Correspondingly, we have positions 955913 and 956109 in <code>chr1</code> of the <em>query</em> genome as alignment stops.</p>
<p>The function <code>get_bps</code> takes in a <code>GBreaks</code> pairwise alignment, and produces a <code>GRanges</code> object of it’s associated alignment stops.</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># get_bps(gbs$Osa_Oki)</span>
<span class="co"># get_bps(gbs$Osa_Oki, direction = "left")</span>
<span class="co"># get_bps(gbs$Osa_Oki,                      stranded = TRUE)</span>
<span class="co"># get_bps(gbs$Osa_Oki,                      stranded = TRUE, sorted = FALSE)</span>
<span class="co"># get_bps(gbs$Osa_Oki, direction = "right", stranded = TRUE)</span>
<span class="co"># get_bps(gbs$Osa_Oki$query, sorted = FALSE)</span>
<span class="co"># get_bps(gbs$Osa_Oki$query)</span></code></pre></div>
<p>Now, let us define a <strong>genomic breakpoint</strong> (or simply breakpoint) to be a genomic structural mutation, arising from breakage and repair of the chromosome. Such structural events include insertion, deletion, inversion and translocation, and often arise during recombination.</p>
<p>This package seeks to determine, of the group of alignment stops, which are likely genomic breakpoints and analyse them. Thus, filtering out alignment stops that are a result of bioinformatic errors.</p>
</div>
<div id="measures-of-distance" class="section level2">
<h2 class="hasAnchor">
<a href="#measures-of-distance" class="anchor"></a>Measures of distance</h2>
<div id="synteny-index" class="section level3">
<h3 class="hasAnchor">
<a href="#synteny-index" class="anchor"></a>Synteny index</h3>
<p>Ad-hoc index measuring to what extent a scaffold of the <em>target</em> genome is mostly aligned to a single scaffold in the <em>query</em> genome. See <code><a href="../reference/synteny_index.html">?GenomicBreaks::synteny_index</a></code> for details. One limitation to the use of this index is that it requires that at least the <em>query</em> genome is a complete chromosome assembly.</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># sapply(gbs, synteny_index)</span>
<span class="co"># sapply(gbs, \(g) swap(g) |&gt; synteny_index())</span></code></pre></div>
</div>
<div id="correlation" class="section level3">
<h3 class="hasAnchor">
<a href="#correlation" class="anchor"></a>Correlation</h3>
<p>Ad-hoc index measuring the correlation of the coordinates of the syntenic alignments in scaffolds of a <em>target</em> genome and their best match in the <em>query</em> genome. See <code><a href="../reference/correlation_index.html">?GenomicBreaks::correlation_index</a></code> for details. This index is more robust to the presence of uncollapsed haplotypes in the <em>query</em> genome.</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># sapply(gbs, correlation_index)</span>
<span class="co"># sapply(gbs, \(g) swap(g) |&gt; correlation_index())</span></code></pre></div>
</div>
</div>
<div id="phylogenetic-cladogram" class="section level2">
<h2 class="hasAnchor">
<a href="#phylogenetic-cladogram" class="anchor"></a>Phylogenetic cladogram</h2>
<p>We assume that the <em>North Pacific</em> and the <em>Atlantic</em> species are more related to each other than to the <em>Okinawan</em> species.</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># requireNamespace("ade4")</span>
<span class="co"># treeLeaf &lt;- function(name, length=NULL) {</span>
<span class="co">#   if(!is.null(length)) length &lt;- paste0(':', length)</span>
<span class="co">#   paste0(name, length)</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># treeNode &lt;- function(branch1, branch2, length = NULL) {</span>
<span class="co">#   if(!is.null(length)) length &lt;- paste0(':', length)</span>
<span class="co">#   paste0('(', branch1, ',', branch2, ')', length)</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># addRoot &lt;- function(branch)  paste0(branch, ";")</span>
<span class="co"># </span>
<span class="co"># tree &lt;-</span>
<span class="co">#   addRoot(</span>
<span class="co">#     treeNode(</span>
<span class="co">#       treeNode( length = 2,</span>
<span class="co">#         treeLeaf("Okinawa", 1),</span>
<span class="co">#         treeLeaf("Kume", 1)</span>
<span class="co">#       ),</span>
<span class="co">#       treeNode( length = 1,</span>
<span class="co">#         treeNode( length = 1,</span>
<span class="co">#           treeLeaf("Osaka", 1),</span>
<span class="co">#           treeLeaf("Aomori", 1)</span>
<span class="co">#         ),</span>
<span class="co">#         treeNode( length =1,</span>
<span class="co">#           treeLeaf("Norway", 1),</span>
<span class="co">#           treeLeaf("Barcelona", 1)</span>
<span class="co">#         )</span>
<span class="co">#       )</span>
<span class="co">#     )</span>
<span class="co">#   )</span>
<span class="co"># </span>
<span class="co"># plot(ade4::newick2phylog(tree))</span></code></pre></div>
</div>
<div id="visualising-alignments" class="section level2">
<h2 class="hasAnchor">
<a href="#visualising-alignments" class="anchor"></a>Visualising alignments</h2>
<p>We can use the function <code>scaf_align_plot</code> to see the alignment of query scaffolds/chromosomes onto a specific target scaffold/chromosome of interest.</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># scaf_align_plot(gbs$Osa_Oki, scaf = "Chr1")</span>
<span class="co"># scaf_align_plot(gbs$Oki_Osa, scaf = "chr1")</span></code></pre></div>
<p>Here we have plotted the alignments on the Okinawa genome (y-axis) onto the Osaka genome, scaffold 2 (x-axis). The coverage of the alignment is the bar along the top.</p>
<p>We can plot alignments for two of the target scaffolds side-by-side, using <code>align_scaf_plot-2</code>. This can be used in aid of superscaffolding.</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># align_scaf_plot_2(gbs$Osa_Oki, scaf = c("Chr1","Chr2"))</span></code></pre></div>
<p>As you can see, scaffold 2 of the query genome aligns to the majority of both target scaffolds. This could be used as evidence to support the superscaffolding of these two scaffolds - in an effort toward chromosomal assembly.</p>
</div>
<div id="coalescing-alignments" class="section level2">
<h2 class="hasAnchor">
<a href="#coalescing-alignments" class="anchor"></a>Coalescing alignments</h2>
<p>Large syntenic regions can often appear cluttered with alignment breaks, spanning just a few basepairs. They are either an artefact (for instance in case of incomplete purge of haplotypes) and or true breakpoint. The algorithm in <code>coalesce_contigs</code> is used to produce a new GRanges object with fewer alignment breaks by coalescing alignments separated by short (user specified) distances. This distance need be agreeable in both the target and query genome in order for the coalscion to happen.</p>
<p>For example, coalescing gaps of less than 500 basepairs in the <code>gbs$Osa_Oki</code> alignment:</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># coa &lt;- sapply(gbs, coalesce_contigs) |&gt; SimpleList()</span>
<span class="co"># sapply(gbs, length)</span>
<span class="co"># sapply(coa, length)</span></code></pre></div>
<p>The resulting GRanges object has far fewer alignments and therefore far fewer alignment stops. The algorithm is an initial step in alignment stop filtering, with the goal of a reduced number of alignment stops that have a high probability of being breakpoints.</p>
<div id="width-summary-plots" class="section level3">
<h3 class="hasAnchor">
<a href="#width-summary-plots" class="anchor"></a>Width summary plots</h3>
<p>The distribution of widths is not the same on long and short arms. For this reason, it would be unwise to filter by width on some operations such as coalescing.</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># width2df &lt;- function(where, what, gbl) {</span>
<span class="co">#   gb &lt;- gbl[[where]]</span>
<span class="co">#   if (length(gb) == 0) return (NULL)</span>
<span class="co">#   data.frame(where = where, what = what, width = width(gb))</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># df &lt;- rbind(</span>
<span class="co">#   # do.call allows a list to replace "..." in a function call</span>
<span class="co">#   do.call(rbind, lapply(names(gbs), width2df, "aligned", gbs)),</span>
<span class="co">#   do.call(rbind, lapply(names(coa), width2df, "collapsed", coa))</span>
<span class="co"># )</span>
<span class="co"># </span>
<span class="co"># ggplot(df) +</span>
<span class="co">#   aes(width, col = what) +</span>
<span class="co">#   geom_freqpoly() +</span>
<span class="co">#   scale_x_log10() +</span>
<span class="co">#   facet_wrap(~where, scales = "free_y")</span>
<span class="co"># </span>
<span class="co"># gg_freq_poly &lt;- function(DF) {</span>
<span class="co">#     ggplot(DF |&gt; as("data.frame")) +</span>
<span class="co">#     aes(width) +</span>
<span class="co">#     geom_freqpoly() +</span>
<span class="co">#     scale_x_log10()</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># DF &lt;- DataFrame(width = width(gbs$Oki_Osa), Type = gbs$Oki_Osa$Type, chr = seqnames(gbs$Oki_Osa))</span>
<span class="co"># </span>
<span class="co"># gg_freq_poly(DF) +</span>
<span class="co">#   aes(col=Type) +</span>
<span class="co">#   facet_wrap(~chr, scales = "free_y")</span></code></pre></div>
<p>After coalescing, width distribution becomes more clearly bimodal, with a small peak under 500 bp, found on all arms except YSR. The second peak shows two different distributions for long and short arms.</p>
<p>Therefore, if the first peak represents events that we do not want to consider breaking synteny (either alignment artefacts or insertion/transpositions of short mobile elements), we can re-coalesce once after removing the shortest intervals.</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># DF &lt;- DataFrame(</span>
<span class="co">#   width = width(coa$Oki_Osa),</span>
<span class="co">#   Type = mcols(OKI_longShort)[findOverlaps(coa$Oki_Osa, OKI_longShort) |&gt; subjectHits(), "Type"],</span>
<span class="co">#   chr = seqnames(coa$Oki_Osa))</span>
<span class="co"># </span>
<span class="co"># gg_freq_poly(DF) +</span>
<span class="co">#   aes(col=Type) +</span>
<span class="co">#   facet_wrap(~chr, scales = "free_y")</span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># coa2 &lt;- sapply(coa, coalesce_contigs, minwidth = 500) |&gt; SimpleList()</span>
<span class="co"># sapply(coa2, length)</span>
<span class="co"># </span>
<span class="co"># DF &lt;- DataFrame(</span>
<span class="co">#   width = width(coa2$Oki_Osa),</span>
<span class="co">#   Type = mcols(OKI_longShort)[findOverlaps(coa2$Oki_Osa, OKI_longShort) |&gt; subjectHits(), "Type"],</span>
<span class="co">#   chr = seqnames(coa2$Oki_Osa))</span>
<span class="co"># </span>
<span class="co"># gg_freq_poly(DF) +</span>
<span class="co">#   aes(col=Type) +</span>
<span class="co">#   facet_wrap(~chr, scales = "free_y")</span></code></pre></div>
</div>
</div>
<div id="genome-plots-with-genoplotr" class="section level2">
<h2 class="hasAnchor">
<a href="#genome-plots-with-genoplotr" class="anchor"></a>Genome plots with genoPlotR</h2>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># library("genoPlotR")</span>
<span class="co"># </span>
<span class="co"># example("dna_seg")</span>
<span class="co"># </span>
<span class="co"># gr2dna_seg &lt;- function (gr) {</span>
<span class="co">#   if (is.null(names(gr))) names(gr) &lt;- as.character(gr)</span>
<span class="co">#   strand(gr[strand(gr) == "*"]) &lt;- "+"</span>
<span class="co">#   df &lt;- data.frame(</span>
<span class="co">#     name   = names(gr),</span>
<span class="co">#     start  = start(gr),</span>
<span class="co">#     end    = end(gr),</span>
<span class="co">#     strand = strand(gr),</span>
<span class="co">#     col    = "grey"</span>
<span class="co">#   )</span>
<span class="co">#   dna_seg(df)</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># gbRef2dna_seq &lt;- function (gb) {</span>
<span class="co">#   if (is.null(names(gb))) names(gb) &lt;- as.character(gb)</span>
<span class="co">#   strand(gb) &lt;- "+"</span>
<span class="co">#   gr2dna_seg(gb)</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># gbQuery2dna_seq &lt;- function (gb) {</span>
<span class="co">#   if (is.null(names(gb$query))) names(gb$query) &lt;- as.character(gb)</span>
<span class="co">#   strand(gb$query) &lt;- strand(gb)</span>
<span class="co">#   gr2dna_seg(gb$query)</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># # Plot whole chromosome 1</span>
<span class="co"># ds &lt;- gr2dna_seg(coa$Oki_Osa[seqnames(coa$Oki_Osa) == "chr1"])</span>
<span class="co"># head(ds) ; tail(ds)</span>
<span class="co"># plot_gene_map(list(ds))</span>
<span class="co"># </span>
<span class="co"># gb2comp &lt;- function(gb) {</span>
<span class="co">#   ref &lt;- gr2dna_seg(gb)</span>
<span class="co">#   strand(gb$query) &lt;- "+"</span>
<span class="co">#   que &lt;- gr2dna_seg(gb$query)</span>
<span class="co">#   df &lt;- data.frame(</span>
<span class="co">#     start1 = ref$start,</span>
<span class="co">#     end1   = ref$end,</span>
<span class="co">#     start2 = que$start,</span>
<span class="co">#     end2   = que$end</span>
<span class="co">#   )</span>
<span class="co">#   as.comparison(df)</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># plotApairOfChrs &lt;- function(gb, chr) {</span>
<span class="co">#   gb &lt;- gb[seqnames(gb) == chr]</span>
<span class="co">#     keepMainMatch &lt;- function(gb) {</span>
<span class="co">#     bestMatch &lt;- tapply(width(gb$query), seqnames(gb$query), sum) |&gt; sort() |&gt; tail(1) |&gt; names()</span>
<span class="co">#     gb[seqnames(gb$query) == bestMatch]</span>
<span class="co">#   }</span>
<span class="co">#   roi &lt;- keepMainMatch(gb)</span>
<span class="co">#   dsList &lt;-   list(</span>
<span class="co">#       roi |&gt; gbQuery2dna_seq(),</span>
<span class="co">#       roi |&gt; gbRef2dna_seq()</span>
<span class="co">#       )</span>
<span class="co">#   </span>
<span class="co">#   compList &lt;- list(</span>
<span class="co">#       roi |&gt; swap() |&gt; gb2comp()</span>
<span class="co">#     )</span>
<span class="co">#   plot_gene_map(dsList, compList)</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># plotApairOfChrs(coa$Oki_Bar, "chr1")</span>
<span class="co"># plotApairOfChrs(coa$Oki_Osa, "chr1")</span>
<span class="co"># plotApairOfChrs(coa$Osa_Oki, "Chr1")</span>
<span class="co"># plotApairOfChrs(coa$Osa_Bar, "Chr1")</span>
<span class="co"># plotApairOfChrs(coa2$Osa_Bar, "Chr1")</span></code></pre></div>
</div>
<div id="combine-alignments-to-the-same-outgroup" class="section level2">
<h2 class="hasAnchor">
<a href="#combine-alignments-to-the-same-outgroup" class="anchor"></a>Combine alignments to the same outgroup</h2>
<p>Since Okinawa is the outgroup, let’s look for regions of it that are aligned on both the Osaka and the Norway genomes.</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># x &lt;- subsetByOverlaps(coa2$Oki_Osa, coa2$Oki_Bar)</span>
<span class="co"># y &lt;- subsetByOverlaps(coa2$Oki_Bar, coa2$Oki_Osa)</span>
<span class="co"># findOverlapPairs(x,y)</span>
<span class="co"># subsetByOverlaps(coa2$Oki_Osa, gaps(coa2$Oki_Bar))</span></code></pre></div>
</div>
<div id="extract-ranges-from-the-same-target-region-in-two-genomicbreaks-objects" class="section level2">
<h2 class="hasAnchor">
<a href="#extract-ranges-from-the-same-target-region-in-two-genomicbreaks-objects" class="anchor"></a>Extract ranges from the same target region in two GenomicBreaks objects</h2>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># #roi &lt;- GRanges("chr1:1222000-1240000")</span>
<span class="co"># #roi &lt;- GRanges("chr1:1023578-1032430")</span>
<span class="co"># #roi &lt;- GRanges("chr1:2668866-2692347")</span>
<span class="co"># roi &lt;- GRanges("chr1:6379932-6505436")</span>
<span class="co"># #roi &lt;- GRanges("chr1:6683567-6744168")</span>
<span class="co"># roi &lt;- GRanges("chr1:7711018-7734330")</span>
<span class="co"># #roi &lt;- GRanges("chr1:7711018-7734330") + 10000</span>
<span class="co"># </span>
<span class="co"># roi_Oki_O &lt;- subsetByOverlaps(coa2$Oki_Osa, roi)</span>
<span class="co"># roi_Oki_N &lt;- subsetByOverlaps(coa2$Oki_Nor, roi)</span>
<span class="co"># roi2 &lt;- range(subsetByOverlaps(coa2$Oki_Osa, roi)$query)</span>
<span class="co"># roi_O_N &lt;- subsetByOverlaps(coa2$Osa_Nor, roi2)</span></code></pre></div>
<div id="plot-a-simple-region-" class="section level3">
<h3 class="hasAnchor">
<a href="#plot-a-simple-region-" class="anchor"></a>Plot a simple region.</h3>
<p>This region can be plotted because there is a one-to-one correspondence between alignments to Osaka and alignments to Norway.</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># roiNameO &lt;- seqlevelsInUse(roi_Oki_O$query)[1]</span>
<span class="co"># roiNameOki &lt;- seqlevelsInUse(roi)[1]</span>
<span class="co"># roiNameN &lt;- seqlevelsInUse(roi_Oki_N$query)[1]</span>
<span class="co"># </span>
<span class="co"># dsList &lt;-   list(</span>
<span class="co">#     roi_Oki_O[seqnames(roi_Oki_O$query) == roiNameO] |&gt; gbQuery2dna_seq(),</span>
<span class="co">#     roi_Oki_O[seqnames(roi_Oki_O$query) == roiNameO] |&gt; gbRef2dna_seq(),</span>
<span class="co">#     roi_Oki_N[seqnames(roi_Oki_N$query) == roiNameN] |&gt; gbRef2dna_seq(),</span>
<span class="co">#     roi_Oki_N[seqnames(roi_Oki_N$query) == roiNameN] |&gt; gbQuery2dna_seq()</span>
<span class="co">#     )</span>
<span class="co"># names(dsList) &lt;- c(roiNameO, roiNameOki, roiNameOki, roiNameN)</span>
<span class="co"># </span>
<span class="co"># tmpgb &lt;- roi_Oki_O</span>
<span class="co"># tmpgb$query &lt;- granges(roi_Oki_N)</span>
<span class="co"># </span>
<span class="co"># compList &lt;- list(</span>
<span class="co">#     roi_Oki_O[seqnames(roi_Oki_O$query) == roiNameO] |&gt; swap() |&gt; gb2comp(),</span>
<span class="co">#     tmpgb |&gt; gb2comp(),</span>
<span class="co">#     roi_Oki_N[seqnames(roi_Oki_N$query) == roiNameN] |&gt; gb2comp()</span>
<span class="co">#   )</span>
<span class="co"># </span>
<span class="co"># plot_gene_map(dsList, compList, dna_seg_scale=TRUE)</span></code></pre></div>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># dsList &lt;-   list(</span>
<span class="co">#     roi_Oki_N[seqnames(roi_Oki_N$query) == roiNameN] |&gt; gbRef2dna_seq(),</span>
<span class="co">#     roi_Oki_O[seqnames(roi_Oki_O$query) == roiNameO] |&gt; gbQuery2dna_seq(),</span>
<span class="co">#     roi_Oki_N[seqnames(roi_Oki_N$query) == roiNameN] |&gt; gbQuery2dna_seq()</span>
<span class="co">#     )</span>
<span class="co"># names(dsList) &lt;- c(roiNameOki, roiNameO, roiNameN)</span>
<span class="co"># </span>
<span class="co"># compList &lt;- list(</span>
<span class="co">#     roi_Oki_O[seqnames(roi_Oki_O$query) == roiNameO] |&gt; gb2comp(),</span>
<span class="co">#     roi_O_N[seqnames(roi_O_N$query) == roiNameN] |&gt; gb2comp()</span>
<span class="co">#   )</span>
<span class="co"># </span>
<span class="co"># plot_gene_map(dsList, compList, dna_seg_scale=TRUE, tree=ade4::newick2phylog(addRoot(treeNode(roiNameOki, treeNode(roiNameO, roiNameN)))))</span></code></pre></div>
</div>
</div>
<div id="trivial-inversions" class="section level2">
<h2 class="hasAnchor">
<a href="#trivial-inversions" class="anchor"></a>Trivial inversions</h2>
<div id="representation" class="section level3">
<h3 class="hasAnchor">
<a href="#representation" class="anchor"></a>Representation</h3>
<p>In the triplet of alignments below below, the middle block is on a different strand than its neighbors, and they would be colinear otherwise. This represents an inversion. <em>Without an outgroup it is not possible to know in which of the target or query genome the break happened.</em></p>
<p>Let’s call “gaps” the unaligned regions between the blocks.</p>
<pre><code>┌───────────────┬───────────────┬───────────────┐
│ XSR:101-200:+ │ XSR:201-300:- │ XSR:301-400:+ │  (OKI2018_I69)
└───────────────┴───────────────┴───────────────┘
┌───────────────┬───────────────┬───────────────┐
│  S1:101-200:+ │  S1:201-300:+ │  S1:301-400:+ │  (OSKA2016)
└───────────────┴───────────────┴───────────────┘</code></pre>
<p>It is represented as:</p>
<div class="sourceCode" id="cb40"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># example("flagInversions")</span>
<span class="co"># </span>
<span class="co"># library("Gviz")</span>
<span class="co"># options(ucscChromosomeNames=FALSE)</span>
<span class="co"># gen &lt;- GenomeAxisTrack(name = "genome")</span>
<span class="co"># trk &lt;- AnnotationTrack(inv, name = "inv")</span>
<span class="co"># plotTracks(list(gen, trk))</span></code></pre></div>
</div>
<div id="number-of-trivial-inversions" class="section level3">
<h3 class="hasAnchor">
<a href="#number-of-trivial-inversions" class="anchor"></a>Number of trivial inversions</h3>
<p>More inversions are found after coalescing colinear blocks because of situations where <code>+ - +</code> was <code>+ - - +</code> before collapsing.</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># sapply(gbs, function(gb) sum(flagInversions(gb)$inv))</span>
<span class="co"># sapply(coa, function(gb) sum(flagInversions(gb)$inv))</span>
<span class="co"># sapply(coa2, function(gb) sum(flagInversions(gb)$inv))</span></code></pre></div>
</div>
<div id="isolate-the-left-side-gaps-in-inversions" class="section level3">
<h3 class="hasAnchor">
<a href="#isolate-the-left-side-gaps-in-inversions" class="anchor"></a>Isolate the left-side gaps in inversions</h3>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># lgaps &lt;- function(reduced_gr) {</span>
<span class="co">#   # Flag inversions.</span>
<span class="co">#   #  WHAT FOLLOWS ASSUMES THAT THE FLAG IS ON THE LEFT-SIDE BLOCK OF THE TRIPLE</span>
<span class="co">#   lgaps &lt;- flagInversions(reduced_gr)</span>
<span class="co">#   # Extract inversions</span>
<span class="co">#   invs &lt;- lgaps[lgaps$inv]</span>
<span class="co">#   # Extend inversion of 1 bp so that they overlap with their neighbor gap</span>
<span class="co">#   invs &lt;- shift(invs, 1)</span>
<span class="co">#   # Remove strand information</span>
<span class="co">#   strand(lgaps) &lt;- "*"</span>
<span class="co">#   # Then extract gap positions ignoring strand</span>
<span class="co">#   lgaps &lt;- gaps(lgaps)</span>
<span class="co">#   # Remove bogus gaps on + and - strands</span>
<span class="co">#   lgaps &lt;- lgaps[strand(lgaps) == "*"] </span>
<span class="co">#   # Return the gaps overlapping with the flagged inversions</span>
<span class="co">#   subsetByOverlaps(lgaps, invs)</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># # Using coa and not gbs for reason on better detection explained above.</span>
<span class="co"># inv.lgaps &lt;- sapply(coa, lgaps) |&gt; SimpleList()</span>
<span class="co"># </span>
<span class="co"># data.frame(width=width(inv.lgaps$Oki_Osa)) |&gt;</span>
<span class="co">#   ggplot(aes(width)) + geom_histogram() +  scale_x_log10()</span>
<span class="co"># </span>
<span class="co"># inv.lgaps.Seq &lt;- SimpleList()</span>
<span class="co"># </span>
<span class="co"># inv.lgaps.Seq$Oki_Osa &lt;- BSgenome::getSeq(OKI2018_I69,  inv.lgaps$Oki_Osa)</span>
<span class="co"># inv.lgaps.Seq$Oki_Kum &lt;- BSgenome::getSeq(OKI2018_I69,  inv.lgaps$Oki_Kum)</span>
<span class="co"># inv.lgaps.Seq$Osa_Oki &lt;- BSgenome::getSeq(OSKA2016v1.9, inv.lgaps$Osa_Oki)</span>
<span class="co"># inv.lgaps.Seq$Osa_Aom &lt;- BSgenome::getSeq(OSKA2016v1.9, inv.lgaps$Osa_Aom)</span>
<span class="co"># inv.lgaps.Seq$Oki_Bar &lt;- BSgenome::getSeq(OKI2018_I69,  inv.lgaps$Oki_Bar)</span>
<span class="co"># inv.lgaps.Seq$Bar_Oki &lt;- BSgenome::getSeq(Bar2_p4,      inv.lgaps$Bar_Oki)</span></code></pre></div>
</div>
<div id="at-richness" class="section level3">
<h3 class="hasAnchor">
<a href="#at-richness" class="anchor"></a>AT richness</h3>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># ## Inverted regions are AT-rich as usual.</span>
<span class="co"># invSeq &lt;- SimpleList()</span>
<span class="co"># invSeq$Oki_Osa &lt;- BSgenome::getSeq(OKI2018_I69,  filterInversions(flagInversions(coa$Oki_Osa)))</span>
<span class="co"># invSeq$Oki_Bar &lt;- BSgenome::getSeq(OKI2018_I69,  filterInversions(flagInversions(coa$Oki_Bar)))</span>
<span class="co"># invSeq$Oki_Kum &lt;- BSgenome::getSeq(OKI2018_I69,  filterInversions(flagInversions(coa$Oki_Kum)))</span>
<span class="co"># invSeq$Kum_Oki &lt;- BSgenome::getSeq(KUM_M3,  swap(filterInversions(flagInversions(coa$Oki_Kum))))</span>
<span class="co"># invSeq$Osa_Oki &lt;- BSgenome::getSeq(OSKA2016v1.9, filterInversions(flagInversions(coa$Osa_Oki)))</span>
<span class="co"># invSeq$Osa_Bar &lt;- BSgenome::getSeq(OSKA2016v1.9, filterInversions(flagInversions(coa$Osa_Bar)))</span>
<span class="co"># invSeq$Osa_Kum &lt;- BSgenome::getSeq(OSKA2016v1.9, filterInversions(flagInversions(coa$Osa_Kum)))</span>
<span class="co"># invSeq$Osa_Aom &lt;- BSgenome::getSeq(OSKA2016v1.9, filterInversions(flagInversions(coa$Osa_Aom)))</span>
<span class="co"># invSeq$Bar_Osa &lt;- BSgenome::getSeq(Bar2_p4,      filterInversions(flagInversions(coa$Bar_Osa)))</span>
<span class="co"># invSeq$Bar_Oki &lt;- BSgenome::getSeq(Bar2_p4,      filterInversions(flagInversions(coa$Bar_Oki)))</span>
<span class="co"># invSeq$Bar_Kum &lt;- BSgenome::getSeq(Bar2_p4,      filterInversions(flagInversions(coa$Bar_Kum)))</span>
<span class="co"># </span>
<span class="co"># sapply(invSeq, \(seq) letterFrequency(seq, "AT", as.prob = TRUE) |&gt; summary())</span>
<span class="co"># genomes.AT</span>
<span class="co"># </span>
<span class="co"># ## But gaps are a bit more AT-rich.</span>
<span class="co"># sapply(inv.lgaps.Seq, \(seq) letterFrequency(seq, "AT", as.prob = TRUE) |&gt; summary())</span>
<span class="co"># </span>
<span class="co"># ## This difference is significant.</span>
<span class="co"># t.test(letterFrequency(invSeq$Oki_Osa, "AT", as.prob = TRUE), letterFrequency(inv.lgaps.Seq$Oki_Osa, "AT", as.prob = TRUE))</span>
<span class="co"># t.test(letterFrequency(invSeq$Osa_Oki, "AT", as.prob = TRUE), letterFrequency(inv.lgaps.Seq$Osa_Oki, "AT", as.prob = TRUE))</span>
<span class="co"># t.test(letterFrequency(invSeq$Oki_Bar, "AT", as.prob = TRUE), letterFrequency(inv.lgaps.Seq$Oki_Bar, "AT", as.prob = TRUE))</span>
<span class="co"># t.test(letterFrequency(invSeq$Oki_Kum, "AT", as.prob = TRUE), letterFrequency(inv.lgaps.Seq$Oki_Kum, "AT", as.prob = TRUE))</span></code></pre></div>
<p>I was tempted to explain this difference with A/T homopolymer stetches. But de novo motif prediction with rGADEM finds AT-rich motifs in any set of Oik sequences that I have tried.</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># library("rGADEM")</span>
<span class="co"># # Slow !</span>
<span class="co"># # Note that GADEM crashes on sequences longer than 50 kbp.</span>
<span class="co"># gadems &lt;- SimpleList()</span>
<span class="co"># gadems$Oki_Osa &lt;- GADEM(inv.lgaps.Seq$Oki_Osa[width(inv.lgaps.Seq$Oki_Osa) &lt; 50000], verbose=1, genome=OKI2018_I69)</span>
<span class="co"># gadems$Oki_Kum &lt;- GADEM(inv.lgaps.Seq$Oki_Kum[width(inv.lgaps.Seq$Oki_Kum) &lt; 50000], verbose=1, genome=OKI2018_I69)</span>
<span class="co"># </span>
<span class="co"># gadems$Osa_Oki &lt;- GADEM(inv.lgaps.Seq$Osa_Oki[width(inv.lgaps.Seq$Osa_Oki) &lt; 50000], verbose=1, genome=OSKA2016v1.9)</span>
<span class="co"># gadems$Osa_Aom &lt;- GADEM(inv.lgaps.Seq$Osa_Aom[width(inv.lgaps.Seq$Osa_Aom) &lt; 50000], verbose=1, genome=OSKA2016v1.9)</span>
<span class="co"># </span>
<span class="co"># </span>
<span class="co"># gadems$Kum_Oki &lt;- GADEM(invSeq$Kum_Oki[width(invSeq$Kum_Oki) &lt; 50000], verbose=1, genome=KUM_M3)</span>
<span class="co"># gadems$Osa_Oki &lt;- GADEM(invSeq$Osa_Oki[width(invSeq$Osa_Oki) &lt; 50000], verbose=1, genome=OSKA2016v1.9)</span>
<span class="co"># # gadem &lt;- GADEM(invSeq_Oki_O[width(invSeq_Oki_O) &lt; 50000], verbose=1, genome=OKI2018_I69)</span>
<span class="co"># # consensus(gadem)</span>
<span class="co"># # [1] "nAAAAwwnnnrAAAAn"</span>
<span class="co"># </span>
<span class="co"># # gadem &lt;- GADEM(lgapsSeq_Oki_O, verbose=1, genome=OKI2018_I69)</span>
<span class="co"># # consensus(gadem)</span>
<span class="co"># # [1] "rAAGCsGCwwmkCGrCTTyn" "nAAAAwwnnwnAAAAAn"    "nTTTsAAAAw"           "nCCTGAsTCAGGkTTTn"    "nTTTTTnnnnrAAAn"      "wTAAGGGTrTCm"</span>
<span class="co"># </span>
<span class="co"># #saveRDS(gadem, file = "lgapsSeq_Oki_O_gadem.rds")</span>
<span class="co"># gadem &lt;- readRDS("lgapsSeq_Oki_O_gadem.rds")</span>
<span class="co"># </span>
<span class="co"># for (n in seq_along(gadem@motifList)) seqLogo::seqLogo(rGADEM::getPWM(gadem)[[n]])</span>
<span class="co"># pwm &lt;- rGADEM::getPWM(gadem)[[1]]</span>
<span class="co"># </span>
<span class="co"># #RGadem positive control: check introns ?</span>
<span class="co"># # set.seed(1664)</span>
<span class="co"># # intr &lt;- sample(intronicParts(tx_OKI), 1000)</span>
<span class="co"># # intr &lt;- BSgenome::getSeq(OKI2018_I69, intr)</span>
<span class="co"># # gadem &lt;- GADEM(intr, verbose=1, genome=OKI2018_I69)</span>
<span class="co"># # &gt; consensus(gadem)</span>
<span class="co"># # [1] "nAAAAwnnwnAAAwn"</span>
<span class="co"># # Also found motifs like rryCAATTbwTkCGmAkyT</span>
<span class="co"># </span>
<span class="co"># </span>
<span class="co"># #RGadem positive control: check promoters ?</span>
<span class="co"># # set.seed(1664)</span>
<span class="co"># # prom &lt;- sample(promoters(tx_OKI), 1000)</span>
<span class="co"># # prom &lt;- BSgenome::getSeq(OKI2018_I69, prom)</span>
<span class="co"># # gadem &lt;- GADEM(prom, verbose=1, genome=OKI2018_I69)</span>
<span class="co"># # consensus(gadem)</span>
<span class="co"># # [1] "nAAAAwwnwnnAAAAwn" "nTTTTCTTyn"       </span>
<span class="co"># # Also found motifs like TTTmAAAA</span></code></pre></div>
<p>A palindromic (rAAGCsGCwwmkCGrCTTyn) motif is found in the left gaps.</p>
<p>Or could it be <code>GCCGCnnnGCGGC</code> ? Its frequency in genomes is something like:</p>
<pre><code>  Oki   Osa   Bar   Kum   Aom   Nor 
10827  2273  1967 10880  2210  2247 </code></pre>
<p>On the other hand, a motif containing GCGAAGCGAA identified in Osa_Oki shows:</p>
<pre><code>  Oki   Osa   Bar   Kum   Aom   Nor 
  483 21360 23340   501 21594 16413 </code></pre>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># checkJaspar &lt;- function (pwm) {</span>
<span class="co">#   #---- see https://compgenomr.github.io/book/motif-discovery.html</span>
<span class="co">#   pwmLib &lt;- getMatrixSet(</span>
<span class="co">#     JASPAR2018::JASPAR2018,</span>
<span class="co">#     opts = list(</span>
<span class="co">#       collection = 'CORE',</span>
<span class="co">#    #   species    = 'Homo sapiens',</span>
<span class="co">#       matrixtype = 'PWM'))</span>
<span class="co">#   </span>
<span class="co">#   pwm_sim &lt;- PWMSimilarity( pwmLib, PWMat,  method = 'Pearson')</span>
<span class="co"># </span>
<span class="co">#   pwmLibDf &lt;- data.frame(</span>
<span class="co">#     ID        = sapply(pwmLib, ID),</span>
<span class="co">#     name      = sapply(pwmLib, name),</span>
<span class="co">#     row.names = seq_along(pwmLib)</span>
<span class="co">#   )</span>
<span class="co">#   pwmLibDf$similarity &lt;- pwm_sim[pwmLibDf$ID]</span>
<span class="co">#   pwmLibDf[order(-pwmLibDf$similarity),]</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># PWMat &lt;- PWMatrix(ID="rAAGCsGCwwmkCGrCTTyn", profileMatrix = pwm)</span>
<span class="co"># pwm_res &lt;- checkJaspar(PWMat)</span>
<span class="co"># head(pwm_res)</span>
<span class="co"># </span>
<span class="co"># pwmhalf &lt;- pwm[,2:8]</span>
<span class="co"># pwmhalf_res &lt;- checkJaspar(PWMatrix(ID="AAGCnGC", profileMatrix = pwmhalf))</span>
<span class="co"># head(pwmhalf_res)</span></code></pre></div>
<p>But a search in Jaspar with either the full motif or its halof did not reveal strong hits. Visual inspection of PRDM9 sequence logos via Google did not show similarity either.</p>
</div>
<div id="export-raagcsgcwwmkcgrcttyn-alignments-to-a-file" class="section level3">
<h3 class="hasAnchor">
<a href="#export-raagcsgcwwmkcgrcttyn-alignments-to-a-file" class="anchor"></a>Export rAAGCsGCwwmkCGrCTTyn alignments to a file</h3>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># gademHitsToBS &lt;- function(gadem, n) {</span>
<span class="co">#   alignList &lt;- gadem[[n]]@alignList</span>
<span class="co">#   pwmSeqs &lt;- sapply(alignList, function(align) align@seq)</span>
<span class="co">#   Biostrings::DNAStringSet(pwmSeqs)</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># pwmSeqs &lt;- gademHitsToBS(gadem, 1)</span>
<span class="co"># writeXStringSet(pwmBS, file="firstGapsGADEMpwm.fasta")</span>
<span class="co"># </span>
<span class="co"># # writeXStringSet(lgapsSeq_Oki_O, file="firstGaps.fasta")</span>
<span class="co"># # I used this FASTA export to search for motifs with GLAM2, and it also</span>
<span class="co"># # returned A/T polymers.</span></code></pre></div>
<p>The GLAM2 motif finder was run on this file, and then to screen the genome. Hits coordinates were encoded in a BED file uploaded to the ZENBU genome browser. Visual inspection gave me the impression that the motif might be related to repeats.</p>
<p>GLAM2 search of the gap sequences did not return a motif similar to “AAGCsGCwwmkCGrCTTyn”.</p>
</div>
<div id="whole-genome-search-of-the-motif" class="section level3">
<h3 class="hasAnchor">
<a href="#whole-genome-search-of-the-motif" class="anchor"></a>Whole-genome search of the motif</h3>
<p>Disappointingly, the motif is found equally in gaps and inversions when searched with its PWM.</p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># No exact match</span>
<span class="co"># vmatchPattern("AAGCsGCwwmkCGrCTTyn", OKI2018_I69)</span>
<span class="co"># </span>
<span class="co"># pwmHits &lt;- sapply(genomes, matchPWM, pwm = pwm)</span>
<span class="co"># sapply(pwmHits, length)</span>
<span class="co"># hist(pwmHits$Oki$score)</span>
<span class="co"># hist(pwmHits$Osa$score)</span>
<span class="co"># </span>
<span class="co"># </span>
<span class="co"># # Less hits, with lower scores, in the mm10 genome.</span>
<span class="co"># pwmHitsmm10 &lt;- matchPWM(pwm, BSgenome.Mmusculus.UCSC.mm10::BSgenome.Mmusculus.UCSC.mm10)</span>
<span class="co"># </span>
<span class="co"># length(subsetByOverlaps(pwmHits$Oki, lgaps_Oki_O))</span>
<span class="co"># length(subsetByOverlaps(pwmHits$Oki, invs))</span>
<span class="co"># </span>
<span class="co"># hist(score(subsetByOverlaps(pwmHits$Oki, lgaps_Oki_O)))</span>
<span class="co"># hist(score(subsetByOverlaps(pwmHits$Oki, invs)))</span>
<span class="co"># </span>
<span class="co"># # Scores in gaps are higher than average.</span>
<span class="co"># t.test(score(pwmHits$Oki), score(subsetByOverlaps(pwmHits$Oki, lgaps_Oki_O)))</span>
<span class="co"># </span>
<span class="co"># # Scores in gaps and inversions are not different </span>
<span class="co"># t.test(score(subsetByOverlaps(pwmHits$Oki, invs)), score(subsetByOverlaps(pwmHits$Oki, lgaps_Oki_O)))</span>
<span class="co"># </span>
<span class="co"># rtracklayer::export.bed(pwmHits, "AAGCsGCwwmkCGrCTTyn.bed")</span>
<span class="co"># </span>
<span class="co"># # PWM hits seem to be more abundant on short arms.</span>
<span class="co"># OKI_longShort$pwmHitsPerMb &lt;- countOverlaps(OKI_longShort, pwmHits$Oki) / width(OKI_longShort) * 1e6</span>
<span class="co"># # But with a naive approach the difference is not statistically significant.</span>
<span class="co"># t.test(c(159, 185, 188), c(77, 142, 160))</span></code></pre></div>
</div>
<div id="representation-of-some-inversions" class="section level3">
<h3 class="hasAnchor">
<a href="#representation-of-some-inversions" class="anchor"></a>Representation of some inversions</h3>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># x &lt;- coa$Oki_Osa |&gt; flagInversions() |&gt; dist2next(ignore.strand = TRUE)</span>
<span class="co"># </span>
<span class="co"># pmpcoord &lt;- showInversions(x)</span>
<span class="co"># </span>
<span class="co"># seqinfo2gieStain &lt;- function(si) {</span>
<span class="co">#   data.frame(</span>
<span class="co">#     chrom      = seqlevels(si),</span>
<span class="co">#     chromStart = 0,</span>
<span class="co">#     chromEnd   = seqlengths(si),</span>
<span class="co">#     name       = seqlevels(si),</span>
<span class="co">#     gieStain   = "gneg"</span>
<span class="co">#   )</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># #r &lt;- 63:70</span>
<span class="co"># r &lt;- 94:98</span>
<span class="co"># #r &lt;- 316:319</span>
<span class="co"># options(ucscChromosomeNames=FALSE)</span>
<span class="co"># gen &lt;- GenomeAxisTrack(name="OKI2018_I69")</span>
<span class="co"># ide &lt;- IdeogramTrack(chromosome = seqlevelsInUse(x[r]), genome = "OKI2018_I69", bands = seqinfo2gieStain(OKI2018_I69))</span>
<span class="co"># trk &lt;- AnnotationTrack(x[r], name = "OKI2018_I69", id=LETTERS[seq_along(r)])</span>
<span class="co"># p1 &lt;- grid::grid.grabExpr(plotTracks(list(ide, gen, trk), featureAnnotation = "id"))</span>
<span class="co"># </span>
<span class="co"># gen2 &lt;- GenomeAxisTrack(name="OSKA2016v1.9")</span>
<span class="co"># ide2 &lt;- IdeogramTrack(chromosome = seqlevelsInUse(x$query[r]), genome = "OSKA2016v1.9", bands = seqinfo2gieStain(OSKA2016v1.9))</span>
<span class="co"># trk2 &lt;- AnnotationTrack(x[r]$query, name = "OSKA2016v1.9", id=LETTERS[seq_along(r)])</span>
<span class="co"># p2 &lt;- grid::grid.grabExpr(plotTracks(list(ide2,gen2,trk2), featureAnnotation = "id"))</span>
<span class="co"># </span>
<span class="co"># gridExtra::grid.arrange(p1, p2, nrow=2)</span></code></pre></div>
</div>
</div>
<div id="trivial-insersions" class="section level2">
<h2 class="hasAnchor">
<a href="#trivial-insersions" class="anchor"></a>Trivial insersions</h2>
<div id="representation-1" class="section level3">
<h3 class="hasAnchor">
<a href="#representation-1" class="anchor"></a>Representation</h3>
<p>The in<b>s</b>ersion below:</p>
<pre><code>┌───────────────┬───────────────┬───────────────┐
│ XSR:101-200:+ │ XSR:201-300:+ │ XSR:301-400:+ │  (OKI2018_I69)
└───────────────┴───────────────┴───────────────┘
┌───────────────┬───────────────┬───────────────┐
│  S1:101-200:+ │  S2:801-900:+ │  S1:201-300:+ │  (OSKA2016)
└───────────────┴───────────────┴───────────────┘</code></pre>
<p>Is represented as:</p>
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># example("flagInsersions")</span>
<span class="co"># </span>
<span class="co"># library("Gviz")</span>
<span class="co"># options(ucscChromosomeNames=FALSE)</span>
<span class="co"># gen &lt;- GenomeAxisTrack(name = "genome")</span>
<span class="co"># trk &lt;- AnnotationTrack(ins, name = "ins")</span>
<span class="co"># plotTracks(list(gen, trk))</span></code></pre></div>
<p><em>Without an outgroup it is not possible to know in which genome the break happened.</em></p>
</div>
<div id="detection" class="section level3">
<h3 class="hasAnchor">
<a href="#detection" class="anchor"></a>Detection</h3>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># sapply(gbs, function(gb) sum(flagInsersions(coalesce_contigs(gb))$ins))</span>
<span class="co"># </span>
<span class="co"># y &lt;- flagInsersions(reduced_gr_Oki_O)</span>
<span class="co"># </span>
<span class="co"># #r &lt;- 63:70</span>
<span class="co"># r &lt;- 23:30</span>
<span class="co"># #r &lt;- 316:319</span>
<span class="co"># options(ucscChromosomeNames=FALSE)</span>
<span class="co"># gen &lt;- GenomeAxisTrack(name="OKI2018_I69")</span>
<span class="co"># ide &lt;- IdeogramTrack(chromosome = seqlevelsInUse(x[r]), genome = "OKI2018_I69", bands = seqinfo2gieStain(OKI2018_I69))</span>
<span class="co"># trk &lt;- AnnotationTrack(x[r], name = "OKI2018_I69", id=LETTERS[seq_along(r)])</span>
<span class="co"># p1 &lt;- grid::grid.grabExpr(plotTracks(list(ide, gen, trk), featureAnnotation = "id"))</span>
<span class="co"># </span>
<span class="co"># gen2 &lt;- GenomeAxisTrack(name="OSKA2016")</span>
<span class="co"># ide2 &lt;- IdeogramTrack(chromosome = seqlevelsInUse(x$query[r])[1], genome = "OSKA2016", bands = seqinfo2gieStain(OSKA2016))</span>
<span class="co"># trk2 &lt;- AnnotationTrack(x[r]$query, name = "OSKA2016", id=LETTERS[seq_along(r)])</span>
<span class="co"># p2 &lt;- grid::grid.grabExpr(plotTracks(list(ide2,gen2,trk2), featureAnnotation = "id"))</span>
<span class="co"># </span>
<span class="co"># </span>
<span class="co"># gen3 &lt;- GenomeAxisTrack(name="OSKA2016")</span>
<span class="co"># ide3 &lt;- IdeogramTrack(chromosome = seqlevelsInUse(x$query[r])[2], genome = "OSKA2016", bands = seqinfo2gieStain(OSKA2016))</span>
<span class="co"># trk3 &lt;- AnnotationTrack(x[r]$query, name = "OSKA2016", id=LETTERS[seq_along(r)])</span>
<span class="co"># p3 &lt;- grid::grid.grabExpr(plotTracks(list(ide3,gen3,trk3), featureAnnotation = "id"))</span>
<span class="co"># </span>
<span class="co"># gridExtra::grid.arrange(p1, p2, p3, nrow=3)</span></code></pre></div>
</div>
</div>
<div id="tandem-repeats" class="section level2">
<h2 class="hasAnchor">
<a href="#tandem-repeats" class="anchor"></a>Tandem repeats</h2>
<p>Repeated regions of genomes are notoriously difficult to assemble and align. Thus, information about an alignment stop’s proximity to a tandem repeat is useful information in breakpoint classification. Given a user-defined tolerance, the function <code>tan_bp</code> will classify alignment stops as either far from, close to, or within tandem repeats (elements 1,2 and 3 of the produced list, respectively). The function requires the tandem repeat coverage of one of the genomes. By default, the function will expect the target genome tandem coverage. Setting <code>query_tf = TRUE</code> will switch the outcome to be query genome oriented.</p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># </span>
<span class="co"># tan_O &lt;- rtracklayer::import.gff3(system.file("extdata/OSKA2016.tantanf4w100.gff3.gz",  package="GenomicBreaks"))</span>
<span class="co"># tan_O &lt;- GRanges(tan_O, seqinfo = seqinfo(OSKA2016))</span>
<span class="co"># tan_gr_O &lt;- tan_bp(gr_ob = gr_O_Oki, tan = tan_O, tol = 50)</span>
<span class="co"># tan_gr_O</span>
<span class="co"># </span>
<span class="co"># tan_Oki &lt;- rtracklayer::import.gff3(system.file("extdata/I69-5.tantanf4w100.gff3.gz",  package="GenomicBreaks"))</span>
<span class="co"># tan_Oki &lt;- GRanges(tan_Oki, seqinfo = seqinfo(OKI2018_I69))</span>
<span class="co"># tan_gr_Oki &lt;- tan_bp(gr_ob = gr_O_Oki, tan = tan_Oki, tol = 50, query_tf = TRUE)</span>
<span class="co"># tan_gr_Oki</span></code></pre></div>
<p>We can use another script to plot the density of tandem repeats around alignment stops (and breakpoints). In the following plots, breakpoints are aligned at the centre of the plots. Intuitively, this function can be generalised to see the density of any binary coverage characteristic around breakpoints, given a GRanges object with per-base coverage of a given characteristic. Here we stick with tandem repeat info:</p>
<div class="sourceCode" id="cb55"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># hm_tan_O &lt;- gr_O_Oki %&gt;%</span>
<span class="co">#   feature_coverage(tan_O, win = 1000, lab = "Osaka ~ Okinawa", direction = "left") %&gt;%</span>
<span class="co">#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel") %T&gt;%</span>
<span class="co">#   plotHeatmap</span>
<span class="co"># </span>
<span class="co"># hm_red_tan_O &lt;- reduced_gr_O_Oki %&gt;%</span>
<span class="co">#   feature_coverage(tan_O, win = 1000, lab = "Osaka ~ Okinawa", direction = "left") %&gt;%</span>
<span class="co">#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel") %T&gt;%</span>
<span class="co">#   plotHeatmap</span>
<span class="co"># </span>
<span class="co"># hm_tan_Oki &lt;- gr_Oki_O %&gt;%</span>
<span class="co">#   feature_coverage(tan_Oki, win = 1000, lab = "Osaka ~ Okinawa", direction = "left") %&gt;%</span>
<span class="co">#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel") %T&gt;%</span>
<span class="co">#   plotHeatmapList</span></code></pre></div>
</div>
<div id="coverage" class="section level2">
<h2 class="hasAnchor">
<a href="#coverage" class="anchor"></a>Coverage</h2>
<p>Another characteristic of alignment stops that we can examine is the coverage depth over said alignment stops. By aligning raw reads to assembled genomes, we can obtain per-base coverage depth for target or query genome. Low coverage directly on and surrounding an alignment stop may suggest unreliability in it being a true breakpoint. The function <code>bp_coverage</code> returns a GRanges object of the bps, with associated averaged and point converage in the metadatacolumns.</p>
<div class="sourceCode" id="cb56"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># cov_gr_O_Oki &lt;- bp_coverage(gr_ob = q_Oki, cov_gr = Oki_cov_pb, win = 50)</span>
<span class="co"># cov_gr_O_Oki</span></code></pre></div>
</div>
<div id="breakpoint-classification---master-script" class="section level2">
<h2 class="hasAnchor">
<a href="#breakpoint-classification---master-script" class="anchor"></a>Breakpoint classification - master script</h2>
<p>The function <code>master_bp_analysis</code> brings together the information about tandem repeats and coverage, as well as coalescing the alignment. It can perform the analyses for both the target and the query genome, depending on the available input data. The output is split into two GRanges objects; one for the target genome and one for the query, with associated information in the metadata columns.</p>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># fin_gr_O_Oki &lt;- master_bp_analysis(pair_gr = gr_O_Oki, co_tol = 500, ref_tan = tan_O, ref_tan_tol = 50, q_tan = tan_Oki,</span>
<span class="co">#                                    q_tan_tol = 50, q_cov = Oki_cov_pb, q_cov_tol = 50)</span>
<span class="co"># fin_gr_O_Oki</span></code></pre></div>
</div>
</div>
<div id="examples" class="section level1">
<h1 class="hasAnchor">
<a href="#examples" class="anchor"></a>Examples</h1>
<div id="nucleaic-acid-content-heatmaps" class="section level2">
<h2 class="hasAnchor">
<a href="#nucleaic-acid-content-heatmaps" class="anchor"></a>Nucleaic acid content heatmaps</h2>
<p>The <em>GenomicBreaks</em> function <code>bp_heatmap</code> plots nucleic acid content in windows centrered on alignment stops. Lets look at <code>GC</code> content before and after coalescing:</p>
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># library(heatmaps)</span>
<span class="co"># hm_GC1 &lt;- sapply(gbs, bp_heatmap, basep_range = 1000, pat = "GC", direction = "left") |&gt; SimpleList()</span>
<span class="co"># hm_GC2 &lt;- sapply(coa, bp_heatmap, basep_range = 1000, pat = "GC", direction = "left") |&gt; SimpleList()</span>
<span class="co"># </span>
<span class="co"># maxHeight &lt;- 2000</span>
<span class="co"># sm_GC1 &lt;- sapply(hm_GC1, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |&gt; SimpleList()</span>
<span class="co"># sm_GC2 &lt;- sapply(hm_GC2, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |&gt; SimpleList()</span>
<span class="co"># sm_GC3 &lt;- sapply(hm_GC3, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |&gt; SimpleList()</span>
<span class="co"># </span>
<span class="co"># plotHeatmapList(sm_GC1)</span>
<span class="co"># plotHeatmapList(sm_GC2)</span>
<span class="co"># plotHeatmapList(sm_GC3)</span></code></pre></div>
<p>The alignment stops are ordered in such a way that start (or left breaks) are centred on the top half of the plot, and end alignment stops are centred on the bottom. This is why we see different directionality in the plots. At the alignment stops, the GC content seems to be lower, but higher once within the aligned region.</p>
<p>Now looking at TATA content:</p>
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># hm_GC1_TATA &lt;- sapply(gbs, bp_heatmap, basep_range = 1000, pat = "TATA", direction = "left") |&gt; SimpleList()</span>
<span class="co"># hm_GC2_TATA &lt;- sapply(coa, bp_heatmap, basep_range = 1000, pat = "TATA", direction = "left") |&gt; SimpleList()</span>
<span class="co"># </span>
<span class="co"># maxHeight &lt;- 2000</span>
<span class="co"># sm_GC1_TATA &lt;- sapply(hm_GC1_TATA, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |&gt; SimpleList()</span>
<span class="co"># sm_GC2_TATA &lt;- sapply(hm_GC2_TATA, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |&gt; SimpleList()</span>
<span class="co"># sm_GC3_TATA &lt;- sapply(hm_GC3_TATA, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |&gt; SimpleList()</span>
<span class="co"># </span>
<span class="co"># plotHeatmapList(sm_GC1_TATA)</span>
<span class="co"># plotHeatmapList(sm_GC2_TATA)</span>
<span class="co"># plotHeatmapList(sm_GC3_TATA)</span></code></pre></div>
<p>The directionaility here is consistent with the <code>GC</code> content analysis. Furthermore; “TATA box sequence can act as a basal promoter element not only for RNA polymerase II (RNAP II) transcription, but also for transcription by RNA polymerase III (RNAP III)” - Wang Y, Jensen RC, Stumph WE. Role of TATA box sequence and orientation in determining RNA polymerase II/III transcription specificity. Nucleic Acids Res. 1996;24(15):3100–3106. <a href="doi:10.1093/nar/24.15.3100" class="uri">doi:10.1093/nar/24.15.3100</a>. However, the areas are not particularly enriched for TATA boxes, so it does not necessarily show that breakpoints are occurring directly after promoter regions.</p>
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># hm_GC1_mot &lt;- sapply(gbs, bp_heatmap, basep_range = 1000, pat = "AGCNGC", direction = "left") |&gt; SimpleList()</span>
<span class="co"># hm_GC2_mot &lt;- sapply(coa, bp_heatmap, basep_range = 1000, pat = "AGCNGC", direction = "left") |&gt; SimpleList()</span>
<span class="co"># </span>
<span class="co"># maxHeight &lt;- 2000</span>
<span class="co"># sm_GC1_mot &lt;- sapply(hm_GC1_mot, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |&gt; SimpleList()</span>
<span class="co"># sm_GC2_mot &lt;- sapply(hm_GC2_mot, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |&gt; SimpleList()</span>
<span class="co"># sm_GC3_mot &lt;- sapply(hm_GC3_mot, smoothHeatmap, output.size = c(maxHeight,     500), algorithm = "kernel") |&gt; SimpleList()</span>
<span class="co"># </span>
<span class="co"># plotHeatmapList(sm_GC1_mot)</span>
<span class="co"># plotHeatmapList(sm_GC2_mot)</span>
<span class="co"># plotHeatmapList(sm_GC3_mot)</span></code></pre></div>
</div>
<div id="cluster-analysis" class="section level2">
<h2 class="hasAnchor">
<a href="#cluster-analysis" class="anchor"></a>Cluster analysis</h2>
<div class="sourceCode" id="cb61"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># # Accessory functions</span>
<span class="co"># clusterHeatmap &lt;- function(hm, k = 2) kmeans(image(hm), k)</span>
<span class="co"># </span>
<span class="co"># orderHeatmap &lt;- function(hm, cl) {</span>
<span class="co">#   image(hm) &lt;- image(hm)[order(cl$cluster),]</span>
<span class="co">#   hm</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># subsetHeatmap &lt;- function(hm, bool) {</span>
<span class="co">#   image(hm) &lt;- image(hm)[bool,]</span>
<span class="co">#   hm</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># # DAta</span>
<span class="co"># hm_GC   &lt;- bp_heatmap(      gr_Oki_O, basep_range  = 1000, pat = "GC",     direction = "left")</span>
<span class="co"># hm_TATA &lt;- bp_heatmap(      gr_Oki_O, basep_range  = 1000, pat = "TATA",   direction = "left")</span>
<span class="co"># hm_tan  &lt;- feature_coverage(gr_Oki_O, tan_Oki, win = 1000, lab = "Tandem", direction = "left")</span>
<span class="co"># </span>
<span class="co"># # Define 3 K-mean clusters</span>
<span class="co"># clusterHeatmap(hm_GC, 3) -&gt; hm_cl_k4</span>
<span class="co"># </span>
<span class="co"># # Order and smooth</span>
<span class="co"># shm_GC &lt;- orderHeatmap(hm_GC, hm_cl_k4) %&gt;%</span>
<span class="co">#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")</span>
<span class="co"># </span>
<span class="co"># shm_TATA &lt;- orderHeatmap(hm_TATA, hm_cl_k4) %&gt;%</span>
<span class="co">#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")</span>
<span class="co"># </span>
<span class="co"># shm_tan &lt;- orderHeatmap(hm_tan, hm_cl_k4) %&gt;%</span>
<span class="co">#   smoothHeatmap(output.size = c(2000,500), algorithm = "kernel")</span>
<span class="co"># </span>
<span class="co"># # Plot the ordered data</span>
<span class="co"># plotHeatmapList(list(shm_GC, shm_TATA, shm_tan))</span>
<span class="co"># par(mfrow = c(1,1)) # plotHeatmapList messes with mrfrow...</span>
<span class="co"># plotHeatmapMeta(list(hm_GC, hm_TATA, hm_tan))</span>
<span class="co"># </span>
<span class="co"># plotHeatmapMeta(list(subsetHeatmap(hm_GC, hm_cl_k4$cluster == 1),</span>
<span class="co">#                      subsetHeatmap(hm_GC, hm_cl_k4$cluster == 2),</span>
<span class="co">#                      subsetHeatmap(hm_GC, hm_cl_k4$cluster == 3)))</span>
<span class="co"># </span>
<span class="co"># kmeanOrderedPlot &lt;- function (hm, k=3, seed = 1) {</span>
<span class="co">#   set.seed(seed)</span>
<span class="co">#   </span>
<span class="co">#   cl &lt;- kmeans(image(hm), k)</span>
<span class="co">#   mat &lt;- image(hm)[order(cl$cluster),]</span>
<span class="co">#   </span>
<span class="co">#   kmhm = Heatmap(</span>
<span class="co">#     mat,</span>
<span class="co">#     coords=c(-500,500),</span>
<span class="co">#     label="kmeans",</span>
<span class="co">#     scale=range(mat))</span>
<span class="co">#   </span>
<span class="co">#   plotHeatmapList(kmhm,</span>
<span class="co">#                   cex.label=1.5,</span>
<span class="co">#                   partition=as.vector(table(cl$cluster)),</span>
<span class="co">#                   partition.legend=TRUE,</span>
<span class="co">#                   partition.lines=TRUE,</span>
<span class="co">#                   legend=TRUE,</span>
<span class="co">#                   legend.pos="r",</span>
<span class="co">#                   legend.width=0.3)</span>
<span class="co"># }</span>
<span class="co"># </span>
<span class="co"># kmeanOrderedPlot(shm_GC)</span></code></pre></div>
</div>
<div id="evidence-for-breakpoint-hotspots" class="section level2">
<h2 class="hasAnchor">
<a href="#evidence-for-breakpoint-hotspots" class="anchor"></a>Evidence for breakpoint hotspots</h2>
<p>The function <code>bp_pair_analysis</code> takes two pairwise alignments with the same target genome, and plots the alignment stops on to the centred alignment stops of the other. In the plot below, Osaka is there consistent target genome, and as such acts as a coordinate system to relate alignment stops across genomes. Lets produce two of these 3-way analyses; one between Osaka-Okinawa-Norway, and one between Osaka-Okinawa-Aomori</p>
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># hm1 &lt;- bp_pair_analysis(gr_ref_q1 = gr_O_Oki, gr_ref_q2 = gr_O_N, win = 1000, lab = "Oki~Nor")</span>
<span class="co"># plotHeatmapMeta(hm1)</span>
<span class="co"># </span>
<span class="co"># hm2 &lt;- bp_pair_analysis(gr_ref_q1 = gr_O_Oki, gr_ref_q2 = gr_O_A, win = 1000, lab = "Oki~Aom")</span>
<span class="co"># plotHeatmapMeta(hm2)</span></code></pre></div>
<p>The accumulation of alignment breaks of one pairwise alignment onto another suggests the existence of breakpoint hotspots; regions where breaks are far more likely to occur. Intuitively, this would lead to the presumption of synteny blocks, also. The pattern is consistent after coalescing, too;</p>
<div class="sourceCode" id="cb63"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># reduced_gr_O_N &lt;- coalesce_contigs(gr_ob = gr_O_N, tol = 500)</span>
<span class="co"># </span>
<span class="co"># hm3 &lt;- bp_pair_analysis(gr_ref_q1 = reduced_gr_O_Oki, gr_ref_q2 = reduced_gr_O_N, win = 1000, lab = "Oki~Nor")</span>
<span class="co"># plotHeatmapMeta(hm3)</span></code></pre></div>
</div>
<div id="tandem-repeat-coverage-around-alignment-stops-breakpoints" class="section level2">
<h2 class="hasAnchor">
<a href="#tandem-repeat-coverage-around-alignment-stops-breakpoints" class="anchor"></a>Tandem repeat coverage around alignment stops (breakpoints)</h2>
<p>The function <code>feature_coverage</code> will plot the coverage of tandem repeats around centred alignment stops.</p>
<div class="sourceCode" id="cb64"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># </span>
<span class="co"># hm_tan1 &lt;- feature_coverage(gr_ob = gr_O_Oki, feat = tan_O, win = 4000, lab = "Osk ~ Oki", direction = "left")</span>
<span class="co"># plotHeatmapMeta(hm_tan1)</span>
<span class="co">#  </span>
<span class="co"># hm_tan2 &lt;- feature_coverage(gr_ob = reduced_gr_O_Oki, feat = tan_O, win = 4000, lab = "OSK~Oki (coalesced)", direction = "left")</span>
<span class="co"># plotHeatmapMeta(hm_tan2)</span>
<span class="co"># </span>
<span class="co"># # should I also add comparison of proportions of tandem proximities before and after coalescion?</span></code></pre></div>
<p>There appears to be less tandem repeats around alignment stops after coalescion, inferring that perhaps that some are artefacts of difficult alignment near to tandem repeats.</p>
</div>
<div id="gene-feature-coverage-around-alignment-stops-breakpoints" class="section level2">
<h2 class="hasAnchor">
<a href="#gene-feature-coverage-around-alignment-stops-breakpoints" class="anchor"></a>Gene feature coverage around alignment stops (breakpoints)</h2>
<p>The function <code>feature_coverage</code> will plot the coverage of tandem repeats around centred alignment stops.</p>
<div class="sourceCode" id="cb65"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># #current_GB &lt;- gr_Oki_O # To ease recomputing with another object</span>
<span class="co"># current_GB &lt;- reduced_gr_Oki_O</span>
<span class="co"># hmList_OKI &lt;- list()</span>
<span class="co"># </span>
<span class="co"># hmList_OKI$genes      &lt;- feature_coverage(current_GB, genes(tx_OKI),                         win = 2000, lab = "Oki genes", direction = "left")</span>
<span class="co"># hmList_OKI$promoters  &lt;- feature_coverage(current_GB, promoters(tx_OKI),                     win = 2000, lab = "Oki promoters", direction = "left")</span>
<span class="co"># hmList_OKI$exons      &lt;- feature_coverage(current_GB, exonicParts(tx_OKI),                   win = 2000, lab = "Oki exons", direction = "left")</span>
<span class="co"># hmList_OKI$introns    &lt;- feature_coverage(current_GB, intronicParts(tx_OKI),                 win = 2000, lab = "Oki introns", direction = "left")</span>
<span class="co"># hmList_OKI$cds        &lt;- feature_coverage(current_GB, cds(tx_OKI),                           win = 2000, lab = "Oki cds", direction = "left")</span>
<span class="co"># hmList_OKI$utrs5      &lt;- feature_coverage(current_GB, unlist(fiveUTRsByTranscript(tx_OKI)),  win = 2000, lab = "Oki 5′ UTRs", direction = "left")</span>
<span class="co"># hmList_OKI$utrs3      &lt;- feature_coverage(current_GB, unlist(threeUTRsByTranscript(tx_OKI)), win = 2000, lab = "Oki 3′ UTRs", direction = "left")</span>
<span class="co"># hmList_OKI$pwm        &lt;- feature_coverage(current_GB, pwmHits                              , win = 2000, lab = "PWM", direction = "left")</span>
<span class="co"># </span>
<span class="co"># plotHeatmapMeta(hmList_OKI)</span>
<span class="co"># plotHeatmapMeta(hmList_OKI$genes)</span>
<span class="co"># plotHeatmapMeta(hmList_OKI[c("exons", "cds")])</span>
<span class="co"># plotHeatmapMeta(hmList_OKI[c("exons", "introns", "utrs5", "utrs3", "pwm")])</span>
<span class="co"># plotHeatmapMeta(hmList_OKI[c("introns", "utrs5", "utrs3", "pwm")])</span>
<span class="co"># plotHeatmapMeta(hmList_OKI[c("utrs5", "utrs3", "pwm")])</span></code></pre></div>
<p>Aligned regions are enriched in exons and depleted in introns. Is it because exons are more alignable or is it because it is deleterous to break genes in exons ?</p>
</div>
<div id="gene-feature-coverage-around-pwm-hits" class="section level2">
<h2 class="hasAnchor">
<a href="#gene-feature-coverage-around-pwm-hits" class="anchor"></a>Gene feature coverage around PWM hits</h2>
<p>Let’s look at coverage around PWM hits of the AAGCsGCwwmkCGrCTTyn motif</p>
<div class="sourceCode" id="cb66"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># current_GB &lt;- pwmHits</span>
<span class="co"># </span>
<span class="co"># hmList_PWM_OKI &lt;- list()</span>
<span class="co"># hmList_PWM_OKI$genes     &lt;- feature_coverage(current_GB, genes(tx_OKI),                         win = 2000, lab = "Oki genes", direction = "left")</span>
<span class="co"># hmList_PWM_OKI$promoters &lt;- feature_coverage(current_GB, promoters(tx_OKI),                     win = 2000, lab = "Oki promoters", direction = "left")</span>
<span class="co"># hmList_PWM_OKI$exons     &lt;- feature_coverage(current_GB, exonicParts(tx_OKI),                   win = 2000, lab = "Oki exons", direction = "left")</span>
<span class="co"># hmList_PWM_OKI$introns   &lt;- feature_coverage(current_GB, intronicParts(tx_OKI),                 win = 2000, lab = "Oki introns", direction = "left")</span>
<span class="co"># hmList_PWM_OKI$cds       &lt;- feature_coverage(current_GB, cds(tx_OKI),                           win = 2000, lab = "Oki cds", direction = "left")</span>
<span class="co"># hmList_PWM_OKI$utrs5     &lt;- feature_coverage(current_GB, unlist(fiveUTRsByTranscript(tx_OKI)),  win = 2000, lab = "Oki 5′ UTRs", direction = "left")</span>
<span class="co"># hmList_PWM_OKI$utrs3     &lt;- feature_coverage(current_GB, unlist(threeUTRsByTranscript(tx_OKI)), win = 2000, lab = "Oki 3′ UTRs", direction = "left")</span>
<span class="co"># </span>
<span class="co"># plotHeatmapMeta(hmList_PWM_OKI)</span>
<span class="co"># plotHeatmapMeta(hmList_PWM_OKI[c("exons", "introns")])</span>
<span class="co"># plotHeatmapMeta(hmList_PWM_OKI[c("exons", "utrs5", "utrs3")])</span>
<span class="co"># plotHeatmapMeta(hmList_PWM_OKI[c("utrs5", "utrs3")])</span></code></pre></div>
<p>They are enriched in introns…</p>
<div class="sourceCode" id="cb67"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># </span>
<span class="co"># # Sandbox to make sanity checks.</span>
<span class="co"># </span>
<span class="co"># a &lt;- reduced_gr_Oki_O</span>
<span class="co"># b &lt;- unlist(fiveUTRsByTranscript(tx_OKI))</span>
<span class="co"># </span>
<span class="co"># hm_a &lt;- feature_coverage(a, b, win = 2000, lab = "All ranges", direction = "left")</span>
<span class="co"># hm_b &lt;- feature_coverage(subsetByOverlaps(a,  b), b, win = 2000, lab = "Subsetted ranges", direction = "left")</span>
<span class="co"># </span>
<span class="co"># plotHeatmapMeta(list(hm_a))</span>
<span class="co"># plotHeatmapMeta(list(hm_b))</span></code></pre></div>
</div>
<div id="okinawa-genome-coverage" class="section level2">
<h2 class="hasAnchor">
<a href="#okinawa-genome-coverage" class="anchor"></a>Okinawa genome coverage</h2>
<p>As previously discussed, low coverage over an alignment stop could lower the likelihood of it being considered as a breakpoint. We have per-base coverage depth information for the Okinawan genome (<code>Oki_cov_pb</code>). However, the coverage of this particular assembly is quite good. In fact, we can investigate the coverge over alignment stops from the information obtained using <code>master_bp_analysis</code>.</p>
<div class="sourceCode" id="cb68"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># fin_Oki &lt;- fin_gr_O_Oki[[2]]</span>
<span class="co"># min_cov &lt;- min(min(fin_Oki$left_cov_pb), min(fin_Oki$right_cov_pb)) # minimum coverage over an alignment stop</span>
<span class="co"># min_cov</span>
<span class="co"># length(fin_Oki[fin_Oki$left_cov_pb == min_cov]) + length(fin_Oki[fin_Oki$right_cov_pb == min_cov]) # how many of the minimum coverage is observed</span>
<span class="co"># length(fin_Oki[fin_Oki$left_cov_pb &lt;= 50]) + length(fin_Oki[fin_Oki$right_cov_pb &lt;= 50]) # how many alignment stops have a coverage of less than or euqal to 50</span></code></pre></div>
<p>We may choose to kick out the one alignment stop for which there is no coverage. However, only 15 out of 34572 alignment stops have a coverage of less than or equal to 50, meaning that it would be hard to exclude more than just a few alignment stops using coverage information for breakpoint analysis.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Charlotte West, Charles Plessy.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
